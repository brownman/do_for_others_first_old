#depend_package: xsel

set -o nounset
echo -e " \t\t\t[LOADER] "
export GUI=true
path=${path:-$dir_product_step}

#####################file know its name:
#file_this=$path/loader.cfg
#######################################
################## clean the log file:

export file_log=$path/txt/log.txt

export file_eval_res=$path/txt/eval_res.txt

export file_test_ok=$path/txt/test_ok.txt
export file_test_err=$path/txt/test_err.txt

export file_trace=$path/txt/trace.txt
export file_clip=$path/txt/clipboard.txt
source $path/share/color.cfg
##################
evaluate_step(){

echo ============
    print_color 37 '[RUNNING]'
    if [ $# -gt 0 ];then
        cmd="$1"
#        echo "cmd: $cmd"
        eval "$cmd" > $file_eval_res
                print_file $file_eval_res
    else
        reason_of_death 'supply a function to evaluage'
    fi
echo ============
}

print_file(){
    local file=$1
#    echo "File:         $file"
    cat $file
}

details(){
    echo -e [$str_ptrn] "File:\t\t$file_cfg"  >> $file_trace
    echo -e [$str_ptrn] "Function:\t\t$func_name" >> $file_trace
    echo -e [$str_ptrn] "Test:\t\t$str_res" >> $file_trace
    str_goto=`grep $func_name $file_cfg -n | cut -d ':' -f1 `
    local cmd="vi $file_cfg +$str_goto"
    echo -e "[$str_ptrn]" "Clipboard:\t\t$cmd" >> $file_trace
    ##create a lazy file - for fast opening the error line
    cmd="echo $cmd | /usr/bin/xsel --clipboard"
    echo "$cmd" > $file_clip
    eval "$cmd"
}
coverage(){
    local str_ptrn="$1"
    let 'res=0'
    str_res=`cat $file_cfg | grep $func_name -A 3 | grep $str_ptrn |  sed "s/#$str_ptrn://g"`
    if [ "$str_res" ];then
        if [ "$str_ptrn" = check ];then
            #we are interested only if there is an error case
            print_color_n 37 '[TEST]'
            echo "$str_res"

            #1>$file_trace

            rm $file_test_err
            rm $file_test_ok
            eval "$str_res" 1>$file_test_ok 2>$file_test_err
            [ -s $file_test_err ] && let 'res=1' || let 'res=0'
            if [ "$res" -eq 0 ];then
                print_color 32 '[OK]'
#                print_file $file_test_ok
            else
                print_color 31 '[ERROR]'
                print_file $file_test_err
                details
                exit
            fi


            #{ print_eval_res;print_line;details;echo -e >&2 "\n___________________[ERROR] while testing:\n";cat $file_clip;exit 1; } || echo evaluation ok
        elif [ "$str_ptrn" = info ];then
            print_color 35 "\t\t$str_res"
        else
            reason_of_death "[TAG] is not recognized - please add an handler for it before continue" "$str_ptrn"
        fi
    else
        echo [UNCOVERED:]
        details 1>$file_trace
        reason_of_death "Empty tag: $str_ptrn" "$func_name" 
    fi

}

steps(){
    #info: run all steps: use the level values to determine the amount of allowed steps
    prefix="$1"
    str=`cat $path/txt/level${prefix}.txt` 
    file_cfg=$path/cfg/steps${prefix}.cfg
    source $file_cfg
    if [ "$str" != '' ];then
        let "max=$str"
        echo -e "\t\t\t\t[LEVELS MAX] $max"

        START=1
        END=$max
        ## save $START, just in case if we need it later ##
        level=$START
        while [[ $level -le $END ]]
        do
print_line
            func_name="step${prefix}${level}"
            echo
            #print_color_n 37 "[STEP]"
            echo -e "$prefix>$level/$max" 
            #"$file_cfg" "$func_name"

            coverage info 
            str_step="step${prefix}${level}"
            evaluate_step "$str_step"
            coverage check 
            ((level = level + 1))
        done
    else
        '[error] loading level.txt file'
    fi
}
steps 00
steps 10
print_color_n 32 '[END]' 
echo 'loader.cfg'
set +o nounset
