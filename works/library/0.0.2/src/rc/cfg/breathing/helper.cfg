#!/bin/bash
#help: the most used functions
#use:           load this file before loading: library.cfg
#description:   contain functions which print gracefully and more               
################# vars: + traps:
export     TIMEOUT_FILE_EDITING=5
export TIMEOUT_PRESENT_FILE=1
export TIMEOUT_RAINBOW=1

#trap 'breakpoint' ERR
#trap 'print_stack' ERR
###################################3
caller(){
    print_func
        echo "caller: 2:  ${FUNCNAME[2]}"
}
#sleep1(){

#caller 2
#caller 3
#}
sleep1(){
    if [ $0 = bash ];then


        num=${1:-1}
    sleep $num


        fi

}
breakpoint(){
    set +o nounset
        print_func
#    notify-send error.cfg "$?"
#optional : use of var: msg
#notify_send1 'breakpoint' 
        local msg=""
#flite1 "error - $msg" &
#echo -n '' >> $file_error
        file_error=/tmp/err

        max=${#FUNCNAME[@]}
    let 'max=max-1'
        for ((i = $max ; i > 0 ; i--)); do
            local str1="${BASH_SOURCE[$i]}"
                local str2="${BASH_LINENO[$i-1]}"
                local str3="${FUNCNAME[$i]}"

                msg="$msg\n$str1:$str2:$str3" 
                echo -e "$msg">> $file_error
                echo  "$str1:$str2:$str3" >> $file_error
                filename="$str1"
                done

                echo

                echo
                echo present_file "$file_error"
#  echo "filename: $filename"
#  echo 'cat file'
#  cat $file_error | head -2
#    echo '' > $file_error
                set -o nounset
                exiting

}

assert_number_in_range(){
#  print_func
    num=$1
        max=$2
        if [ $num -lt $max ];then
            trace ok
        else
#    let "num=$max-1"
            reason_of_death          'number is not in range' "$num / $max"
#sleep1 5
                fi

}
print_func(){
    let    'num=1'
        name="${FUNCNAME[$num]}"
        str=$(higher "$name")
        color=${1:-32}
    print_color $color "[ $str ]\t"
}
print_func_n(){
    let    'num=1'
        name="${FUNCNAME[$num]}"
        str=$(higher "$name")
        color=${1:-32}
    print_color_n $color "[ $str ]\t"
}

print_func1(){
    echo print_func

#   let 'num=1'
# ${1:-1}

#max=${#FUNCNAME[@]}
#    assert_number_in_range "$num" "$max"

        if [ $num -lt $max ];then
            echo  'ok'
        else
            echo 'fix back'
                let "num=1"
                fi

#   name="${FUNCNAME[ $num ]}"

#        echo "---> ${FUNCNAME[$num]}()"
}

assert_string_not_empty(){
#    print_func

    str="$1"


        if [ -n "$str" ];then

            num=$( echo "$str" | wc -c )
                trace  'string has X chars:' "$num"
        else
            reason_of_death 'string is empty'
                fi
}
sleep1_steps(){
    max=$1
        for ((i=0; i<$max; i++));do
            sleep1 1
                echo -n '.'
                done

}
clear(){
    print_func
        sleep1 1
        echo -n '.'
        /usr/bin/clear
}
wrap_sh(){
    script=$1
        cmd="vi $script"
        update_clipboard "$cmd"
#execute_in_subshell(){
    print_func
        echo
        echo
#    rm /tmp/out1
#    rm /tmp/err1
        eval "$script" 1>>$file_out 2>>$file_err
        res=$?
        echo '[RESULTS]'

        if [ "$res" -eq 0 ];then
            cat1 $file_out | head -2
        else
            cat1 $file_err | head -2
                parse_error_line $file_err
                fi

                echo
}

print_rainbow_file(){
#print_func
    file=$1

        num=$2
        cleaner_file "$file" $num

        file=$file_tmp
#cat1 $file
#return
#    let 'counter=1'
        while read line;do
#        num=$1
#        let    "sum=30+$counter"
#        let 'res=$num mod 7'
            random 7
                let "counter=31+$?"

# if [ $counter -lt 7 ];then
                print_color "${counter}" "$line"
# else
#     echo -e "$counter)\t$line"
# fi
                sleep1 $TIMEOUT_RAINBOW
                done<$file
}
random_color(){
#print_func

random 8

res=$?
let "res=$res+31"
#echo "$res"
return $res
}
print_rainbow_line(){
#print_func
    line=$1
        file=/tmp/empty
        echo "$line" > $file
        echo "$line" >> $file
        echo "$line" >> $file
        echo "$line" >> $file
        echo "$line" >> $file

        let 'counter=1'
        while read line;do
            num=$1
                let    "sum=30+$counter"
#        let 'res=$num mod 7'
                if [ $counter -lt 7 ];then
                    print_color "3${counter}" "$line"
                else
                    echo -e "$counter)\t$line"
                        fi

                        let "counter+=1"

                        sleep1 $TIMEOUT_RAINBOW
                        done<$file
}


sleep12(){
#reason: dont run if executer is not bash
    delay=$1
        if [ "$0" = bash ];then
            sleep1 $delay
                fi

}
cleaner_file(){

    file=$1
        num=${2:-0}
    file_tmp=/tmp/cleaner_file
        grep -v '^#' $file | grep -v '^$' > $file_tmp

#update+shrink the file if num is non-zero
        if [ $num -ne 0 ];then
            cat $file_tmp | head -"${num}" > $file_tmp
                fi
}
cat1(){
    util=/bin/cat
        file=$1
        file_tmp=/tmp/file_tmp
        grep -v '^#' $file | grep -v '^$' > $file_tmp
        echo $file

        if [ $# -eq 1 ];then
            $util $file  | head -5
        else

            delay=${2:1}

    while  read line;do
        echo "$line"
            sleep1 $delay
            done < $file_tmp


            fi

}



skip(){
#echo skipping
#print_func
    echo "$@" >> $file_skip
}

returning(){
    return
}
exporting() 
{ 
    print_func_n
#    sleep12 6
        export_name=$1
        something=$2
        if [ -d "$something" ];then
            dir=$something

                echo "$export_name"
                assert_dir_exist "$dir"
                cmd="export $export_name=$dir"
                trace "$cmd"
                echo "$cmd" >> $file_logger
                eval "$cmd"
                aliasing_dir "$export_name"
                elif [ -f "$something" ];then
                file=$something

                assert_file_exist "$file"
                cmd="export $export_name=$file"
                trace "$cmd"
                echo "$cmd" >> $file_logger
                eval "$cmd"
                aliasing_file "$export_name"
        else
            reason_of_death 'not found' "$something"

                fi

}

aliasing_dir(){
#print_func 33
    dir_name=$1

        target="\$$dir_name"

        str=$(echo $dir_name | sed 's/dir_//g')
        from="cd${str}";

    str1="alias $from='cd $target'";
# echo "$str"
    echo "$str1" >> $file_aliases;


    from="test_${str}";
    str1="alias $from=\"$target/tests/test.sh\"";
# echo "$str"
    echo "$str1" >> $file_aliases;

}

aliasing_file() 
{ 
    file="$1";
    assert_file_exist "$file"
        base=$(basename $file | cut -d'.' -f1)
        type=$(basename $file | cut -d'.' -f2)


#sed 's/.cfg//g';
        from="edit_${base}";
    str="alias $from='vi $file'";
    echo "$str" >> $file_aliases;
    from="${base}E";
    str="alias $from='vi $file'";
    echo "$str" >> $file_aliases;
    if [ "$type" = 'sh' ];then
        from="sh_${base}";
    str="alias $from='exec $file'";
    echo "$str" >> $file_aliases;


    fi

}
sourcing (){
    print_func_n 37
    echo "$@"
# sleep12 1
    file="$1"
        assert_file_exist "$file"
        trace "sourcing $file"
        aliasing_file $file
        source $file

}
load_txt(){
#sleep12 1
    file="$1"
        if [ -f "$file" ];then
            str0=$(basename $file) 
                str=$(higher "$str0")
#      line=$(cat $file | head -1)
                aliasing_file $file
#    echo -n "[ $str ]"
#   echo -e "\t$line"
                print_file "$file" 1

        else
            reason_of_death 'no such file' "$file"
                fi

}


sleep121(){
    echo '.'
        trace "caller: ${FUNCNAME[1]}"
}



################# traps:

install_trap(){
#cmd: what to do whith the control+c trap ?

    if [ -s "$file" ];then

# print_func
        cmd0="$1"
            cmd="trap \"$cmd0\" SIGINT"
#echo "$cmd"
            eval "$cmd"


    else
        trace        'empty file' "$file"
            fi

            sleep12 $TIMEOUT_FILE_EDITING

}
## array
str_to_arr(){
#depend on: arr
    local str="$1"
        local delimeter=${2-'.'}
    IFS=$delimeter read -a arr <<< "$str"
#result: arr
}

################  validations 
######## ASSERTION
assert_cmd_is_valid(){
    cmd="$1"
        $(type "$cmd")>/dev/null
        res=$?
        if [ $res -eq 0 ];then
            trace 'command is valid' "$cmd"
        else
            reason_of_death 'invalid command' "$cmd"
                fi
}


assert_file_not_empty(){
    echo
#echo '[ ASSERT ]  '
local        file="$1"
        if [ -s "$file" ];then

            echo 'file: passed the indication: -s' "$file" 
        else
            reason_of_death  'file is empty' "$file"
                fi
                res=$( echo `du $file` | cut -d' ' -f1 )
                if [ "$res" -ne 0 ];then
                    echo 'file has content: ' "$file" 
                else
                    reason_of_death 'file size is 0' "$file"
                        fi

}

assert_dir_exist(){
#print_func
    dir=$1

        assert_string_not_empty "$dir"
        if [ -d "$dir" ];then
            trace        'dir exist' "$dir" 
        else
            reason_of_death  'directory not exist' "$dir" 
                fi
}


assert_file_exist(){
#    print_func


    file="$1"
        assert_string_not_empty "$file"
        if [ -f "$file" ];then
            trace 'file exist' "$file" 
        else
            reason_of_death  'file not exist' "$file"
                fi
}

########### handlers:
edit_file(){
#SIGNAL SIGINT
    print_func
        file=${1:-$file}
    assert_file_exist "$file" 
        vi $file
}
remind_test(){
#SIGNAL ERR
    print_func
        echo 'run test.sh'
}


############################## everyday funcs:
remove_trailing(){
    trace 'remove_trailing'
        local res=$(echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g')
        echo "$res"

}  

print_line() 
{ 
    hr='----------------------------------------------------------------';
    printf '%s' "${hr:0:${COLUMNS:-$(tput cols)}}";
    echo
}

#print_func() 
#{ 
#    local str="${FUNCNAME[1]}";
#}
#
breakpoint_line(){
#print_func
    line=${1:-$LINENO}
#func=${1:-''}
    print_line
        print_line

        print_color 33 "[BREAKPOINT ON LINE x HAS BEEN SET]"
#echo "LINE: $line"
#echo "FUNC: $func"

#echo "lineno: $LINENO"
#echo "lineno s:${LINENO[@]}"

        cmd="vi $0 +$line"
#echo "$cmd"
        update_clipboard "$cmd"
        print_line
        print_line
}


trace(){
#    echo ',,'
    f2=${FUNCNAME[2]}
    f1=${FUNCNAME[1]}
    msg="$f1,$f2: $@"
        echo "$msg" >> $file_logger
}

every() 
{ 

    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};

    random $num;
    local res=$?;
#    local output='';
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "1/$num"
# trace "cmd: $cmd";
            eval "$cmd_do";
    else
#echo
# print_func
#echo
        eval "$cmd_else";
#    notify-send "skip" "$num";
    fi;
#    return $res
}
random() 
{ 
#    print_func;

    local num=$1
        let "r = $RANDOM % $num";
    return $r
}



update_clipboard(){
    print_func
    cmd="$1"
#    echo 'updated with:'
#        echo "$cmd"
        notify-send 'update' 'clipboard'

        echo "$cmd" | /usr/bin/xsel --clipboard
        sleep 5
}
print_stack(){
    echo
        echo
        print_line
        print_func
        print_line
        echo
        set +o nounset
        echo -n '[STACK]' 
        local num=${1:-0}
    echo "$num"
        max="${#FUNCNAME[@]}"
        echo "max funcs: $max"
        sleep1 5

        if [ $num -le $max ];then
            sleep1 1
                local caller="${FUNCNAME[$num]}"
                local lineno="${BASH_LINENO[$num-1]}"
                local filename="${BASH_SOURCE[$num]}"
                echo "[ CALL ][$num][$caller]: $filename"
        else
            reason_of_death "stack length is: $max"
                fi
}

print_color() 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n() 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}
exiting() 
{ 
    flite1 -t exiting
    print_color 31 '[EXITING]'
#    echo "SHLVL: $SHLVL"
#        exit 1
        return 1
}
print_shlvl(){
    print_func_n
    
echo "$SHLVL"
    }
warning(){
    print_func 31
        echo "$@"
}
reason_of_death() 
{
# echo >&2 
    print_line;
    every 5 print_shlvl 'skip printing the shlvl'
    print_color_n 31 '[REASON_OF_DEATH]' 
        msg0="reason of death:";
    msg1='';
    msg2='';
    str1="${1:-''}";
    str2=${2:-''};
    stack_index=${3:-'2'};
    echo "$stack_index"
        if [ "$str1" ]; then
            msg1="Why?\t\t $str1";
    fi;
    if [ "$str2" ]; then
        msg2="Name:\t\t $str2";
    fi;
    print_color 31 "$msg0";
    echo -e "\t$msg1";
    echo -e "\t$msg2";
    echo;
    print_line;
    flite1 "$str1";

#print_line
#    breakpoint
#    print_line

#   print_stack $stack_index

#echo "executer is: $0"

    exiting
}
present_file(){

    print_func_n 33
        local     file="$1"
        offset=${2:-0}
    num=`cat $file | wc -l`

        local msg="[ file:$file ] [ lines:$num ] [ offset:$offset ]"
echo "$msg"
#    delay=${3:-$TIMEOUT_PRESENT_FILE}
#echo random 2
#$(    random 2 )
#local res=$?
#let  "delay=$res"
#echo "delay: $delay"



        if [ -f "$file" ];then



#cmd="vi $file"
#update_clipboard  "$cmd"
#update_clipboard_vi
            #filename=$(basename $file)
            #    str=$(higher $filename)
            #    echo -ne "[ $str ]\t"
                if [ $offset -eq 0 ];then
                        print_line
#cat1 $file $delay
                        cat $file
                        elif [ $offset -gt 0 ];then
                        cat $file | head -"${offset}"
                else
                    cat $file | tail -"${offset}"
                        fi

#        install_trap 'edit_file'
        else
            reason_of_death 'not a file' "$file"
                fi


}


higher() { echo ${@^^}; }
print_script(){
    name="$0"
        str=$(higher "$name")
#    echo "$str"
        color=${1:-32}
    print_color_n $color "[ $str ]\t"
}

##################################### traverse
traverse_dir_with_cmd(){
    dir="$1"
        cmd="$2"
        assert_cmd_is_valid "$cmd"
        if [ -d "$dir" ];then
            items=$(ls  "$dir")
                for item in $items;do
                    eval "$cmd $item"
                        done
        else
            reason_of_death 'invalid dir' "$dir"
                fi
}

traverse_dir(){
    dir=$1
        if [ -d "$dir" ];then
            items=$(ls  "$dir")
                for item in $items;do
                    notify-send "$item"
                        done
        else
            reason_of_death 'invalid dir' "$dir"
                fi
}

######## scrap

######## parse
scrap_smart_quote(){
    echo
        print_func
}
parse_error_line(){
    print_func
        something="$1"
        if [ -f $something ];then


         local   file=$something

                assert_file_not_empty "$file"
                line=$(cat $file)
        else
            echo 'I have got a line!'
                line=$something
                fi

#line="$1"
                if [ -n "$line" ];then

                    echo "[LINE] $line"
                        arr=()
                        str_to_arr "$line" ':'
                        max="${#arr[@]}"
                        if [ "$max" -gt 1 ];then
                            echo
                                echo '[DETAILS]'
                                echo "file:" "${arr[0]}"
                                echo "line:" "${arr[1]}"
                                echo "msg:" "${arr[2]}"
                                echo
                                str_line=$(echo "${arr[1]}" | sed 's/line//g'| sed 's/ //g')

                                str_file="${arr[0]}"

                                str_command="${arr[2]}"
                                str_msg="${arr[3]}"
                                cmd="vi $str_file +$str_line"

msg=`echo "$str_command" "$str_msg" | sed 's/ /_/g'`
                               # notify-send "parse_msg:" "$msg"

                                update_clipboard "$cmd"
                        else

                            reason_of_death 'incorrect parsing of line' "$file"
                                fi
                else
                    reason_of_death 'got empty line from file' "$file"
                        fi
}



###################################################################
###################################################################
################################### IndeX #########################
###################################################################
###################################################################

######## printing
export -f print_shlvl
export -f random_color
export -f print_func_n
export -f sleep1
export -f print_func
export -f print_script
export -f present_file
export -f print_line
export -f print_color
export -f print_color_n
export -f reason_of_death
export -f print_stack
export -f trace 
export -f print_rainbow_file
export -f print_rainbow_line
export -f cat1
export -f clear
export -f warning

#workflow
export -f every
export -f random
export -f exiting
##remind
export -f remind_test


#regular expressions
export -f higher
export -f remove_trailing

#traverse
export -f traverse_dir

##parse
export -f parse_error_line
export -f str_to_arr
export -f update_clipboard
export -f breakpoint_line


#scrapping
export -f scrap_smart_quote
#proxy calls/loaders
export -f sourcing
export -f exporting
export -f returning
export -f skip
export -f load_txt
#export -f load_cfg


#assertions
export -f assert_file_not_empty
export -f assert_file_exist
export -f assert_dir_exist
export -f assert_cmd_is_valid

#### traps:

export -f wrap_sh
export -f cleaner_file

export -f assert_string_not_empty
export -f assert_number_in_range

export -f breakpoint
: <<COMMENTED
echo  skdfjlksdjflksjfdklj
COMMENTED
