########################### RULES ********
# - use a wallpaper script to print the logs as output-of-the-day - on the desktop wallpaper!
# - handeling of errors - must be set here - because the loop must always running - because it is the best indicator for the user's efforts and effectivity !
#
# - project is a sub-project and it is independant of external changes!
# - reason: sos.sh must run no-metter what!
###########################################

shopt -s expand_aliases

echo -e "\t\t\tLoading: setup.cfg"
breakpoint() {
max_b_s="${#BASH_SOURCE[@]}"
echo "max bash sources array:         $max_b_s"

    STACK=""
    # to avoid noise we start with 1 to skip get_stack caller
    local i
    local stack_size=${#FUNCNAME[1]}
    for (( i=1; i<$stack_size ; i++ )); do
        local func="${FUNCNAME[$i]}"
        [ x$func = x ] && func=MAIN
        local linen="${BASH_LINENO[(( i - 1 ))]}"
if [ $max_b_s -eq 1 ];then
    src=$0
    else

       src="${BASH_SOURCE[$i-1]}"
    fi
        [ x"$src" = x ] && src=non_file_source
        STACK+=$'\n'"   "$func" "$src" "$linen
        echo "$STACK"
    done
}
breakpoint11 () 
{ 
    print_func;
    local msg="";
    file_error=/tmp/err;
    echo -n '' > $file_error
    max=${#FUNCNAME[@]};
    let 'max=max-1';
    for ((i = $max ; i > 0 ; i--))
    do
        echo "bash source: ${BASH_SOURCE[@]}"
        sleep 6
        local str1="${BASH_SOURCE[$i]}";
        local str2="${BASH_LINENO[$i-1]}";
        local str3="${FUNCNAME[$i]}";
        msg="$msg\n$str1:$str2:$str3";
        echo -e "$msg" >> $file_error;
        echo "$str1:$str2:$str3" >> $file_error;
        filename="$str1";
    done;
    echo;
    echo
    echo "file_log: $file_logger"
    cat $file_logger

    echo '------'
    echo "file_error: $file_error"
    cat $file_error;
    echo '' > $file_error;
    echo
    echo

    exiting
}

sleep1(){
    echo -n '.'
}
update_clipboard(){
    print_func
    cmd="$@" 

    echo "$cmd" | /usr/bin/xsel --clipboard
    #notify-send 'update_clipboard' "$cmd"
    sleep 5
}
exiting(){
    echo exiting
    exit 1
}
trace(){
    echo "$@" >/dev/null
}
update_logger(){
    print_func
    if [ $# -gt 0  ];then
        script="$1"
        cmd="vi $script"
        update_clipboard "$cmd" 
        shift
        args=( "$@" )

        num="${#args[@]}"
        words="${args[@]:-()}"
        echo "$script [  $num  ]  $words" >> $file_logger
    else
        reason_of_death 'no arguments'
    fi
}


zenity1(){
    TIMEOUT_ZENITY=20
    #find . -name '*.txt' 
    local file="$1"
    local title=${2:-"title"}
    local text=${3:-"text"}
    #${3:-'text0'}
    #local editable="$4"
    #    notify_send "$editable"
    #local res=$(
    cat $file
    sleep 6
    local res=$(cat $file | zenity --list --title "$file" --text "$text" --column "Files" --editable --timeout $TIMEOUT_ZENITY)

    local notify1=$(cat $file | head -1)
    notify-send "$notify1"

    echo "$res"
}


reason_of_death(){

    echo "script: $0"
    print_func 2
    print_func
    why="${1:-''}"
    who="${2:-''}"

    echo "why: $why"
    echo "who: $who"
    gxmessage "why:$why|  who:$who" -title 'reason of death'
    exiting
}
print_func_content(){
    print_func
    #wrapper.sh 
    #steps
    file=$1
    funcname=$2
    sed -n "/$funcname(/,/}/p" $file

}
print_layout(){
    print_func
    #reason: view how many working/non-working plugins?
    #tree $dir_workspace
    tree $dir_singles -L 1
}


generate_indicator(){
    print_func

    local    task=${1:-''}

    local str_task=`echo "$task" | grep bin`

    if [ "$str_task" ];then

        assert_file_exist "$dir_root/$task"
        xcowsay "generate indicator for:  $task"
        #reason: it is possible to indicate if a certain task is running by using a symlink - which the system print in color -> when the link is broken - the shell willl print the non-active task in red. 
        #action: use a simple cron jobs to clean files at /tmp/INDICATOR vs create a file with the name: tasker_cli(for example) when this process is running
        file_lock_indicator=`basename $task | sed 's/.sh//g'  `
        echo "creating indicator for a running bin/task:  name: $file_lock_indicator"
        if [ -d "$dir_indicator" ];then
            touch $dir_indicator/$file_lock_indicator
        else
            reason_of_death 'no such dir' "$dir_indicator"
        fi
    else
        trace 'reasoning: task is not a script in bin/' "$task"
    fi
}

print_func(){
    num=${1:-1}
    echo "---> ${FUNCNAME[${num}]}()"
}
creation_of_symlink(){
    print_func
    from=$1 #outer space
    to=$2 #desktop folder, etc..

    echo "creating symlink"
    echo "from: $from "
    echo "to: $to"

    if [ ! -d "$to" ];then
        ln -s $from $to
    else
        echo 'symlink exist' "$to"
    fi
}
creation_of_dir(){
    print_func
    local dir=$1
    if [ ! -d "$dir" ];then
        mkdir -p $dir
    else 
        echo 'already existed: ' "$dir"
    fi
}
breakpoint01(){
    print_func
    flite -t 'error'
    str="$0: $LINENO"
    gxmessage -title 'local Breakpoint' "$str"
}
install_trap(){
    print_func
    trap breakpoint01 ERR
}


validate_root(){
    print_func
    if [ ! -d "$dir_root"  ];then
        echo "must be executed after dir_root was set"
        exit
    else 
        echo "dir_root is running" "dir_root is: $dir_root"
    fi
}
export_struct(){
    print_func
    export dir_indicator=/tmp/CRONING/INDICATORS    
    export dir_log=$dir_root/log
    export dir_singles=$dir_root/singles
    export single_sh=$dir_singles/single.sh


    export dir_singles_cli=$dir_root/singles_cli

    export dir_old_sh=$dir_root/OLD/sh
    export dir_old_cfg=$dir_root/OLD/cfg

    export single_cli_sh=$dir_singles_cli/single_cli.sh

    export suspend_sh="$dir_root/singles/suspend/suspend.sh"
    export translate_sh="$dir_root/singles/translation/translation.sh"

    export dir_workspace=$dir_root/WORKSPACE
    export ln_desktop=~/Desktop/ROUNDS
    export file_logger=$dir_log/log.txt
}
export_vars(){
    print_func
    export GXMESSAGE='-sticky -ontop'
    export SOUND=true
    export NAME=ofer
}
print_script(){
    local str=`basename $0`
    echo  -e " [ script ] : $str"


}
export_funcs(){
    print_func
    export -f reason_of_death
    export -f breakpoint
    export -f print_layout
    export -f print_script
    export -f zenity1
    export -f update_logger 
    export -f exiting
    export -f update_clipboard
    export -f sleep

}

#print_script
#print_func
#print_color
#print_color_n


##################################################### dir_struct
steps(){

    validate_root
    export_struct

    export_vars
    export_funcs

#    install_trap


    creation_of_dir "$dir_indicator"
    creation_of_dir "$dir_workspace"
    creation_of_dir "$dir_workspace/list"
    creation_of_symlink    $dir_root/WORKSPACE ~/Desktop
}
#tasker(){
#print_func
#args=( "$@" )
#cmd="${args[@]}"
#echo "$cmd"
#sleep 2
#eval "$cmd"
#
#}
#alias validate_root="tasker validate_root"

#steps
#steps(){
#validate_root
#}
steps
