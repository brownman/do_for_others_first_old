shopt -s expand_aliases

echo -e "\t\t\tLoading: setup.cfg"
reason_of_death(){
    
echo "script: $0"
    print_func 2
    print_func
why="${1:-''}"
who="${2:-''}"

echo "why: $why"
echo "who: $who"
gxmessage "why:$why|  who:$who" -title 'reason of death'
exit 1
}
print_func_content(){
print_func
    #wrapper.sh 
    #steps
    file=$1
    funcname=$2
    sed -n "/$funcname(/,/}/p" $file

}
print_layout(){
    print_func
    #reason: view how many working/non-working plugins?
    #tree $dir_workspace
    tree $dir_singles -L 1
}


generate_indicator(){
    print_func

    local    task=${1:-''}
    local task=`echo "$task" | grep bin`

    if [ -f "$task" ];then
    xcowsay "generate indicator for:  $task"
    #reason: it is possible to indicate if a certain task is running by using a symlink - which the system print in color -> when the link is broken - the shell willl print the non-active task in red. 
    #action: use a simple cron jobs to clean files at /tmp/INDICATOR vs create a file with the name: tasker_cli(for example) when this process is running
    file_lock_indicator=`basename $task | sed 's/.sh//g'  `
    echo $file_lock_indicator
    if [ -d "$dir_indicator" ];then
        touch $dir_indicator/$file_lock_indicator
    else
        reason_of_death 'no such dir' "$dir_indicator"
    fi
else
    echo 'task is not a script in bin/' "$task"
fi
}

print_func(){
    num=${1:-1}
    echo "---> ${FUNCNAME[${num}]}()"
}
creation_of_symlink(){
    print_func
    from=$1 #outer space
    to=$2 #desktop folder, etc..

        echo "creating symlink"
        echo "from: $from "
        echo "to: $to"

    if [ ! -d "$to" ];then
        ln -s $from $to
    else
        echo 'symlink exist' "$to"
    fi
}
creation_of_dir(){
    print_func
    local dir=$1
    if [ ! -d "$dir" ];then
        mkdir -p $dir
    else 
        echo 'already existed: ' "$dir"
    fi
}
breakpoint(){
    print_func
    flite -t 'error'
    notify-send "$0"
    gxmessage -title 'local Breakpoint' "$0"
}
install_trap(){
    print_func
    trap breakpoint ERR
}


validate_root(){
    print_func
    if [ ! -d "$dir_root"  ];then
        echo "must be executed after dir_root was set"
        exit
    else 
        echo "dir_root is running" "dir_root is: $dir_root"
    fi
}
export_struct(){
    print_func
    export dir_indicator=/tmp/CRONING/INDICATORS    
    export dir_log=$dir_root/.LOG
    export dir_singles=$dir_root/singles
    export single_sh=$dir_singles/single.sh

    export dir_singles_cli=$dir_root/singles_cli
    export single_cli_sh=$dir_singles_cli/single_cli.sh

    export suspend_sh="$dir_root/singles/suspend/suspend.sh"
    export translate_sh="$dir_root/singles/translation/translation.sh"

    export dir_workspace=$dir_root/WORKSPACE
    export ln_desktop=~/Desktop/ROUNDS
}
export_vars(){
    print_func
    export GXMESSAGE='-sticky -ontop'
    export SOUND=true
    export NAME=ofer
}
export_funcs(){
print_func
export -f reason_of_death
export -f breakpoint
export -f print_layout
}
#print_script
#print_func
#print_color
#print_color_n


##################################################### dir_struct
steps(){

    validate_root
    export_struct

    export_vars
    export_funcs

    #install_trap


    creation_of_dir "$dir_indicator"
    creation_of_dir "$dir_workspace"
    creation_of_dir "$dir_workspace/list"
    creation_of_symlink    $dir_root/WORKSPACE ~/Desktop
}
#tasker(){
#print_func
#args=( "$@" )
#cmd="${args[@]}"
#echo "$cmd"
#sleep 2
#eval "$cmd"
#
#}
#alias validate_root="tasker validate_root"

#steps
#steps(){
#validate_root
#}
steps
