#help: the most used functions
#use:           load this file before loading: library.cfg
#description:   contain functions which print gracefully and more               
################# vars:
export     TIMEOUT_FILE_EDITING=5
skip(){
#echo skipping
#print_funcname
echo "$@" >> $file_skip
}

returning(){
    return
}
exporting() 
{ 
    print_funcname 35
#    sleep 6
    export_name=$1
    dir=$2
echo "$export_name"
    assert_dir_exist "$dir"
    cmd="export $export_name=$dir"
   # echo "$cmd"
    eval  "$cmd"

aliasing_dir "$export_name"
}

aliasing_dir(){
    print_funcname 33
   dir_name=$1

        target="\$$dir_name"
        
        str=`echo $dir_name | sed 's/dir_//g'`
        from="cd${str}";
        
        str="alias $from='cd $target'";
        echo "$str"
        echo "$str" >> $file_aliases;
}

aliasing_file() 
{ 
    file="$1";
    assert_file_exist "$file"
        base=`basename $file | sed 's/.cfg//g'`;
        from="edit_${base}";
        str="alias $from='vi $file'";
        echo "$str" >> $file_aliases;
#        source $file
        from="${base}E#";
        str="alias $from='vi $file'";
        echo "$str" >> $file_aliases;
    #    source $file

}
sourcing (){
    #    print_funcname
    # sleep 1
    file="$1"
    assert_file_exist "$file"
    echo "$file"
    source $file
    aliasing_file $file
}
load_txt(){
    #sleep 1
    file="$1"
    if [ -f "$file" ];then
        str0=`basename $file` 
        str=`higher "$str0"`
        #      line=`cat $file | head -1`
        aliasing_file $file
        #    echo -n "[ $str ]"
        #   echo -e "\t$line"
        print_file "$file" 1

    else
        reason_of_death 'no such file' "$file"
    fi

}


sleep1(){
    echo '.'
    trace "caller: ${FUNCNAME[1]}"
}



################# traps:

install_trap(){

    if [ -s "$file" ];then

        # print_funcname
        cmd0="$1"
        cmd="trap \"$cmd0\" SIGINT"
        #echo "$cmd"
        eval "$cmd"


    else
        trace        'empty file' "$file"
    fi

    sleep $TIMEOUT_FILE_EDITING

}
## array
str_to_arr(){
    #depend on: arr
    local str="$1"
    local delimeter=${2-'.'}
    IFS=$delimeter read -a arr <<< "$str"
    #result: arr
}

################  validations 
######## ASSERTION
assert_cmd_is_valid(){
    cmd="$1"
    `type "$cmd"`>/dev/null
    res=$?
    if [ $res -eq 0 ];then
        trace 'command is valid' "$cmd"
    else
        reason_of_death 'invalid command' "$cmd"
    fi
}


assert_file_not_empty(){
    echo
    echo '[ ASSERT ]  '
    file="$1"
    if [ -s "$file" ];then
        echo 'file has content: ' "$file" 
    else
        reason_of_death  'file is empty' "$file"
    fi
}

assert_dir_exist(){
    dir="$1"
    if [ -d "$dir" ];then
trace        'dir exist' "$dir" 
    else
        reason_of_death  'directory not exist' "$dir"
    fi
}


assert_file_exist(){
    file="$1"
    if [ -f "$file" ];then
        trace 'file exist' "$file" 
    else
        reason_of_death  'file not exist' "$file"
    fi
}

########### handlers:
edit_file(){
    #SIGNAL SIGINT
    print_funcname
    file=${1:-$file}
    assert_file_exist "$file" 
    vi $file
}
remind_test(){
    #SIGNAL ERR
    print_funcname
    echo 'run test.sh'
}


############################## everyday funcs:
remove_trailing(){
    trace 'remove_trailing'
    local res=$(echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g')
    echo "$res"

}  

print_line() 
{ 
    hr='----------------------------------------------------------------';
    printf '%s' "${hr:0:${COLUMNS:-$(tput cols)}}";
    echo
}

print_func() 
{ 
    local str="${FUNCNAME[1]}";
    echo "---> $str()" 1>&2
}
#
breakpoint_line(){
    #print_func
    line=${1:-''}
    #func=${1:-''}
    print_line
    print_line

    print_color 33 "[BREAKPOINT ON LINE x HAS BEEN SET]"
    #echo "LINE: $line"
    #echo "FUNC: $func"

    #echo "lineno: $LINENO"
    #echo "lineno s:${LINENO[@]}"

    cmd="vi $0 +$line"
    #echo "$cmd"
    update_clipboard "$cmd"
    print_line
    print_line
}


trace(){
    echo ',,'
    f2=${FUNCNAME[2]}
    f1=${FUNCNAME[1]}
    msg="$f1,$f2: $@"
    echo "$msg" >> $file_logger
}

every() 
{ 
    print_funcname
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};

    random $num;
    local res=$?;
    #    local output='';
    if [ $res -eq 0 ]; then
        #   trace "cmd: $cmd";
        eval "$cmd_do";
    else
        eval "$cmd_else";
        #    notify-send "skip" "$num";
    fi;
    #    return $res
}
random() 
{ 
    #    print_func;

    local num=$1
    let "r = $RANDOM % $num";
    return $r
}



update_clipboard(){
    cmd="$1"
    print_color 32 '[CLIPBOARD] '
    #    echo 'updated with:'
    echo "$cmd"

    echo "$cmd" | /usr/bin/xsel --clipboard
}
print_stack(){
    set +o nounset
    #    echo_err '[STACK]' 
    local num=${1:-2}
    max="${#FUNCNAME[@]}"
    if [ $num -le $max ];then
        local caller="${FUNCNAME[$num]}"
        local lineno="${BASH_LINENO[$num-1]}"
        local filename="${BASH_SOURCE[$num]}"
        #$0:$filename:
        local callers="$lineno:$0:$filename"
        cmd="vi $0 +$lineno"
        update_clipboard "$cmd"
        #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
        #trace "secret callers:: $callers"
        echo "$callers"

    else
        reason_of_death "stack length is: $max"
    fi


}

print_color() 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n() 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}
exiting() 
{ 
    print_color_n 31 '__'
    #exiting..;
    #    echo "SHLVL: $SHLVL"
    exit 1
}
reason_of_death() 
{
    # echo >&2 
    print_line;
    print_color 31 '[REASON_OF_DEATH]' 
    msg0="reason of death:";
    msg1='';
    msg2='';
    str1="${1:-''}";
    str2=${2:-''};
    stack_index=${3:-'2'};
    if [ "$str1" ]; then
        msg1="Why?\t\t $str1";
    fi;
    if [ "$str2" ]; then
        msg2="Name:\t\t $str2";
    fi;
    print_color 31 "$msg0";
    echo -e "\t$msg1";
    echo -e "\t$msg2";
    echo;
    print_line;
    /usr/bin/flite "$str1";

    print_stack $stack_index

    echo "executer is: $0"

        exiting
}
print_file(){
    file="$1"
    offset=${2:-0}
    if [ -f "$file" ];then
        echo
        filename=`basename $file`
        str=`higher $filename`
        echo -ne "[ $str ]\t"
        if [ $offset -eq 0 ];then
            echo
            print_line
            cat $file
            echo
        elif [ $offset -gt 0 ];then
            cat $file | head -"${offset}"
        else
            cat $file | tail -"${offset}"
        fi

        #        install_trap 'edit_file'
    else
        reason_of_death 'not a file' "$file"
    fi


}


higher() { echo ${@^^}; }

print_funcname(){
    name="${FUNCNAME[1]}"
    str=`higher "$name"`
#    echo "$str"
color=${1:-32}
    print_color_n $color "[ $str ]\t"
}
##################################### traverse
traverse_dir_with_cmd(){
    dir="$1"
    cmd="$2"
    assert_cmd_is_valid "$cmd"
    if [ -d "$dir" ];then
        items=`ls  "$dir"`
        for item in $items;do
            eval "$cmd $item"
        done
    else
        reason_of_death 'invalid dir' "$dir"
    fi
}

traverse_dir(){
    dir=$1
    if [ -d "$dir" ];then
        items=`ls  "$dir"`
        for item in $items;do
            notify-send "$item"
        done
    else
        reason_of_death 'invalid dir' "$dir"
    fi
}

######## scrap

######## parse
parse_error_line(){
    print_funcname
    line="$1"
    arr=()
    `str_to_arr "$line" \:`
    max="${#arr[@]}"
    if [ "$max" -gt 1 ];then
        echo ok
        echo "file:" "${arr[0]}"
        echo "line:" "${arr[1]}"
        echo "msg:" "${arr[2]}"
    else
        reason_of_death 'incorrect parsing of line' "$line"
    fi
}
parse_error_line1(){
    line="$1"

    item1=`echo  "$line" | cut -d':' -f1`
    item2=`echo  "$line" | cut -d':' -f2`
    item3=`echo  "$line" | cut -d':' -f3`

    echo "file:" "$item1"
    echo "line:" "$item2"
    echo "msg:" "$item3"
}
scrap_smart_quote(){
    echo
    print_funcname
}

###################################################################
###################################################################
################################### IndeX #########################
###################################################################
###################################################################

######## printing
export -f print_func
export -f print_file
export -f print_line
export -f print_color
export -f print_color_n
export -f reason_of_death
export -f print_stack
export -f trace 






#workflow
export -f every
export -f random
export -f exiting


#printing
export -f remind_test

#self
export -f print_funcname

#regular expressions
export -f higher
export -f remove_trailing

#traverse
export -f traverse_dir

##parse
export -f parse_error_line
export -f str_to_arr
export -f update_clipboard
export -f breakpoint_line


#scrapping
export -f scrap_smart_quote
#proxy calls/loaders
export -f sourcing
export -f exporting
export -f returning
export -f skip
export -f load_txt
#export -f load_cfg


#assertions
export -f assert_file_not_empty
export -f assert_file_exist
export -f assert_dir_exist
export -f assert_cmd_is_valid

#### traps:
#trap 'remind_test' ERR

