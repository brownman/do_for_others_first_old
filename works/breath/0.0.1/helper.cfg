#help: the most used functions
#use:           load this file before loading: library.cfg
#description:   contain functions which print gracefully and more               
################# vars: + traps:
export     TIMEOUT_FILE_EDITING=5
export TIMEOUT_PRESENT_FILE=1
#trap 'print_stack' ERR
###################################3
print_rainbow_file(){
    print_func
    file=$1
    let 'counter=1'
    while read line;do
        num=$1
        let    "sum=30+$counter"
        #        let 'res=$num mod 7'
        if [ $counter -lt 7 ];then
            print_color "3${counter}" "$line"
        else
            echo -e "$counter)\t$line"
        fi

        let "counter+=1"
    done<$file
}
print_rainbow_line(){
    print_func
    line=$1
    file=/tmp/empty
    echo "$line" > $file
    echo "$line" >> $file
    echo "$line" >> $file
    echo "$line" >> $file
    echo "$line" >> $file

    let 'counter=1'
    while read line;do
        num=$1
        let    "sum=30+$counter"
        #        let 'res=$num mod 7'
        if [ $counter -lt 7 ];then
            print_color "3${counter}" "$line"
        else
            echo -e "$counter)\t$line"
        fi

        let "counter+=1"
    done<$file
}


sleep2(){
    #reason: dont run if executer is not bash
    delay=$1
    if [ $0 = bash ];then
        sleep $delay
    fi

}
cat1(){
    util=/bin/cat
    file=$1
    file_tmp=/tmp/file_tmp
    grep -v '^#' $file | grep -v '^$' > $file_tmp
    echo $file
    #exiting

    if [ $# -eq 1 ];then
        $util $file 
    else

        delay=$2

        while  read line;do
            echo "$line"
            sleep2 $delay
        done < $file_tmp


    fi

}



skip(){
    #echo skipping
    #print_func
    echo "$@" >> $file_skip
}

returning(){
    return
}
exporting() 
{ 
    print_func 35
    #    sleep2 6
    export_name=$1
    dir=$2
    #echo "$export_name"
    assert_dir_exist "$dir"
    cmd="export $export_name=$dir"
    echo "$cmd"
    echo "$cmd" >> $file_logger
    eval "$cmd"

    aliasing_dir "$export_name"
}

aliasing_dir(){
    #print_func 33
    dir_name=$1

    target="\$$dir_name"

    str=`echo $dir_name | sed 's/dir_//g'`
    from="cd${str}";

    str="alias $from='cd $target'";
    # echo "$str"
    echo "$str" >> $file_aliases;
}

aliasing_file() 
{ 
    file="$1";
    assert_file_exist "$file"
    base=`basename $file | sed 's/.cfg//g'`;
    from="edit_${base}";
    str="alias $from='vi $file'";
    echo "$str" >> $file_aliases;
    #        source $file
    from="${base}E";
    str="alias $from='vi $file'";
    echo "$str" >> $file_aliases;
    #    source $file

}
sourcing (){
    #    print_func
    # sleep2 1
    file="$1"
    assert_file_exist "$file"
    echo "$file"
    source $file
    aliasing_file $file
}
load_txt(){
    #sleep2 1
    file="$1"
    if [ -f "$file" ];then
        str0=`basename $file` 
        str=`higher "$str0"`
        #      line=`cat $file | head -1`
        aliasing_file $file
        #    echo -n "[ $str ]"
        #   echo -e "\t$line"
        print_file "$file" 1

    else
        reason_of_death 'no such file' "$file"
    fi

}


sleep21(){
    echo '.'
    trace "caller: ${FUNCNAME[1]}"
}



################# traps:

install_trap(){
    #cmd: what to do whith the control+c trap ?

    if [ -s "$file" ];then

        # print_func
        cmd0="$1"
        cmd="trap \"$cmd0\" SIGINT"
        #echo "$cmd"
        eval "$cmd"


    else
        trace        'empty file' "$file"
    fi

    sleep2 $TIMEOUT_FILE_EDITING

}
## array
str_to_arr(){
    #depend on: arr
    local str="$1"
    local delimeter=${2-'.'}
    IFS=$delimeter read -a arr <<< "$str"
    #result: arr
}

################  validations 
######## ASSERTION
assert_cmd_is_valid(){
    cmd="$1"
    `type "$cmd"`>/dev/null
    res=$?
    if [ $res -eq 0 ];then
        trace 'command is valid' "$cmd"
    else
        reason_of_death 'invalid command' "$cmd"
    fi
}


assert_file_not_empty(){
    echo
    echo '[ ASSERT ]  '
    file="$1"
    if [ -s "$file" ];then
        echo 'file has content: ' "$file" 
    else
        reason_of_death  'file is empty' "$file"
    fi
}

assert_dir_exist(){
    dir="$1"
    if [ -d "$dir" ];then
        trace        'dir exist' "$dir" 
    else
        reason_of_death  'directory not exist' "$dir"
    fi
}


assert_file_exist(){
    file="$1"
    if [ -f "$file" ];then
        trace 'file exist' "$file" 
    else
        reason_of_death  'file not exist' "$file"
    fi
}

########### handlers:
edit_file(){
    #SIGNAL SIGINT
    print_func
    file=${1:-$file}
    assert_file_exist "$file" 
    vi $file
}
remind_test(){
    #SIGNAL ERR
    print_func
    echo 'run test.sh'
}


############################## everyday funcs:
remove_trailing(){
    trace 'remove_trailing'
    local res=$(echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g')
    echo "$res"

}  

print_line() 
{ 
    hr='----------------------------------------------------------------';
    printf '%s' "${hr:0:${COLUMNS:-$(tput cols)}}";
    echo
}

#print_func() 
#{ 
#    local str="${FUNCNAME[1]}";
#    echo "---> $str()" 1>&2
#}
#
breakpoint_line(){
    #print_func
    line=${1:-''}
    #func=${1:-''}
    print_line
    print_line

    print_color 33 "[BREAKPOINT ON LINE x HAS BEEN SET]"
    #echo "LINE: $line"
    #echo "FUNC: $func"

    #echo "lineno: $LINENO"
    #echo "lineno s:${LINENO[@]}"

    cmd="vi $0 +$line"
    #echo "$cmd"
    update_clipboard "$cmd"
    print_line
    print_line
}


trace(){
    #    echo ',,'
    f2=${FUNCNAME[2]}
    f1=${FUNCNAME[1]}
    msg="$f1,$f2: $@"
    echo "$msg" >> $file_logger
}

every() 
{ 
    print_func
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};

    random $num;
    local res=$?;
    #    local output='';
    if [ $res -eq 0 ]; then
        #   trace "cmd: $cmd";
        eval "$cmd_do";
    else
        eval "$cmd_else";
        #    notify-send "skip" "$num";
    fi;
    #    return $res
}
random() 
{ 
    #    print_func;

    local num=$1
    let "r = $RANDOM % $num";
    return $r
}



update_clipboard(){
    cmd="$1"
    print_color 32 '[CLIPBOARD] '
    #    echo 'updated with:'
    echo "$cmd"

    echo "$cmd" | /usr/bin/xsel --clipboard
}
print_stack(){
    echo
    echo
    print_func
    echo
    set +o nounset
    #    echo_err '[STACK]' 
    local num=${1:-0}
    max="${#FUNCNAME[@]}"

    echo "max funcs: $max"
    # echo "choosen index: $num"

    if [ $num -le $max ];then
        local caller="${FUNCNAME[$num]}"
        local lineno="${BASH_LINENO[$num-1]}"
        local filename="${BASH_SOURCE[$num]}"
        #$0:$filename:
        #local callers="$lineno:$0:$filename"
        #        cmd="vi $0 +$lineno"

        #        update_clipboard "$cmd"
        #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
        #trace "secret callers:: $callers"
        echo "[ CALL ][$num]: $filename"
        # exiting
    else
        reason_of_death "stack length is: $max"
    fi

    exiting

}

print_color() 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n() 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}
exiting() 
{ 
    print_color_n 31 '__'
    #exiting..;
    #    echo "SHLVL: $SHLVL"
    exit 1
}
reason_of_death() 
{
    # echo >&2 
    print_line;
    print_color 31 '[REASON_OF_DEATH]' 
    msg0="reason of death:";
    msg1='';
    msg2='';
    str1="${1:-''}";
    str2=${2:-''};
    stack_index=${3:-'2'};
    if [ "$str1" ]; then
        msg1="Why?\t\t $str1";
    fi;
    if [ "$str2" ]; then
        msg2="Name:\t\t $str2";
    fi;
    print_color 31 "$msg0";
    echo -e "\t$msg1";
    echo -e "\t$msg2";
    echo;
    print_line;
    /usr/bin/flite "$str1";

    print_stack $stack_index

    echo "executer is: $0"

    exiting
}
present_file(){
    print_func
    file="$1"
    offset=${2:-0}
    #    delay=${3:-$TIMEOUT_PRESENT_FILE}
    #echo random 2
    $(    random 2 )
    local res=$?
    let  "delay=$res"
    echo "delay: $delay"

    if [ -f "$file" ];then

        cmd="vi $file"
        update_clipboard  "$cmd"

        echo
        filename=`basename $file`
        str=`higher $filename`
        echo -ne "[ $str ]\t"
        if [ $offset -eq 0 ];then
            echo
            print_line
            cat1 $file $delay
            echo
        elif [ $offset -gt 0 ];then
            cat $file | head -"${offset}"
        else
            cat $file | tail -"${offset}"
        fi

        #        install_trap 'edit_file'
    else
        reason_of_death 'not a file' "$file"
    fi


}


higher() { echo ${@^^}; }

print_func(){
    name="${FUNCNAME[1]}"
    str=`higher "$name"`
    #    echo "$str"
    color=${1:-32}
    print_color_n $color "[ $str ]\t"
}
##################################### traverse
traverse_dir_with_cmd(){
    dir="$1"
    cmd="$2"
    assert_cmd_is_valid "$cmd"
    if [ -d "$dir" ];then
        items=`ls  "$dir"`
        for item in $items;do
            eval "$cmd $item"
        done
    else
        reason_of_death 'invalid dir' "$dir"
    fi
}

traverse_dir(){
    dir=$1
    if [ -d "$dir" ];then
        items=`ls  "$dir"`
        for item in $items;do
            notify-send "$item"
        done
    else
        reason_of_death 'invalid dir' "$dir"
    fi
}

######## scrap

######## parse
parse_error_line(){
    print_func
    file=$1
line=`    cat $file`
    #line="$1"
echo "$line"
    arr=()
    str_to_arr "$line" ':'
    max="${#arr[@]}"
    if [ "$max" -gt 1 ];then
        echo
        echo '[DETAILS]'
        echo "file:" "${arr[0]}"
        echo "line:" "${arr[1]}"
        echo "msg:" "${arr[2]}"
        echo
        str_line=`echo "${arr[1]}" | sed 's/line//g'| sed 's/ //g'`

        str_file="${arr[0]}"
        str_msg="${arr[2]}"
        cmd="vi $str_file +$str_line"
        notify-send "$str_msg"
        update_clipboard "$cmd"
    else
        reason_of_death 'incorrect parsing of line' "$line"
    fi
}
scrap_smart_quote(){
    echo
    print_func
}

###################################################################
###################################################################
################################### IndeX #########################
###################################################################
###################################################################

######## printing
export -f print_func
export -f present_file
export -f print_line
export -f print_color
export -f print_color_n
export -f reason_of_death
export -f print_stack
export -f trace 
export -f print_rainbow_file
export -f print_rainbow_line
export -f cat1

#workflow
export -f every
export -f random
export -f exiting
##remind
export -f remind_test


#regular expressions
export -f higher
export -f remove_trailing

#traverse
export -f traverse_dir

##parse
export -f parse_error_line
export -f str_to_arr
export -f update_clipboard
export -f breakpoint_line


#scrapping
export -f scrap_smart_quote
#proxy calls/loaders
export -f sourcing
export -f exporting
export -f returning
export -f skip
export -f load_txt
#export -f load_cfg


#assertions
export -f assert_file_not_empty
export -f assert_file_exist
export -f assert_dir_exist
export -f assert_cmd_is_valid

#### traps:

wrap_sh(){
    script=$1
    cmd="vi $script"
    update_clipboard "$cmd"
    #execute_in_subshell(){
    print_func
    echo
    echo
    eval "$script" 1>/tmp/out1 2>/tmp/err1
    res=$?
    echo '[RESULTS]'

    if [ $res -eq 0 ];then
        cat1 /tmp/out1
    else
        cat1 /tmp/err1
        parse_error_line /tmp/err1
    fi

    echo
}
export -f wrap_sh
