remove_trailing(){
        trace 'remove_trailing'
        local res=$(echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g')
        echo "$res"

    }  

print_line() 
{ 
        hr='----------------------------------------------------------------';
            printf '%s' "${hr:0:${COLUMNS:-$(tput cols)}}";
                echo
            }

assert_file_not_empty(){
    echo
    echo '[ ASSERT ]  '
    file="$1"
  if [ -f "$file" ];then
        echo 'file exist' "$file" 
    else
        reason_of_death  'file not exist' "$file"
    fi

    if [ -s "$file" ];then
        echo 'file has content: ' "$file" 
    else
        reason_of_death  'file is empty' "$file"
    fi
}
print_func() 
{ 
    local str="${FUNCNAME[1]}";
    echo "---> $str()" 1>&2
}
#
breakpoint_line(){
    #print_func
    line=${1:-''}
    #func=${1:-''}
    print_line
    print_line

    print_color 33 "[BREAKPOINT ON LINE x HAS BEEN SET]"
    #echo "LINE: $line"
    #echo "FUNC: $func"

    #echo "lineno: $LINENO"
    #echo "lineno s:${LINENO[@]}"

    cmd="vi $0 +$line"
    #echo "$cmd"
    update_clipboard "$cmd"
    print_line
    print_line
}


trace(){
    echo ',,'
    msg="${FUNCNAME[2]}: $@"
    echo "$msg" >> $file_logger
}

every() 
{ 
    local num=$1;
    local cmd_do="$2";
    local cmd_else="$3";
    echo "$1";
    echo "$2";
    echo "$3";
    random $num;
    local res=$?;
    local output='';
    if [ $res -eq 0 ]; then
        #   trace "cmd: $cmd";
        eval "$cmd_do";
    else
        eval "$cmd_else";
        #    notify-send "skip" "$num";
    fi;
    return $res
}
random() 
{ 
    #    print_func;

    local num="${1:-5}";
    let "r = $RANDOM % $num";
    return $r
}



update_clipboard(){
    cmd="$1"
    print_color 32 '[CLIPBOARD] '
    #    echo 'updated with:'
    echo "$cmd"

    echo "$cmd" | /usr/bin/xsel --clipboard
}
print_stack(){
    set +o nounset
#    echo_err '[STACK]' 
    local num=${1:-2}
    max="${#FUNCNAME[@]}"
    if [ $num -le $max ];then
        local caller="${FUNCNAME[$num]}"
        local lineno="${BASH_LINENO[$num-1]}"
        local filename="${BASH_SOURCE[$num]}"
        #$0:$filename:
        local callers="$lineno:$0:$filename"
        cmd="vi $0 +$lineno"
        update_clipboard "$cmd"
        #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
        #trace "secret callers:: $callers"
        echo "$callers"

    else
        reason_of_death "stack length is: $max"
    fi


}

print_color() 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n() 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}
exiting() 
{ 
    print_color_n 31 '__'
    #exiting..;
    #    echo "SHLVL: $SHLVL"
    exit 1
}
reason_of_death() 
{
   # echo >&2 
    print_line;
    print_color 31 '[REASON_OF_DEATH]' 
    msg0="reason of death:";
    msg1='';
    msg2='';
    str1="${1:-''}";
    str2=${2:-''};
    stack_index=${3:-'2'};
    if [ "$str1" ]; then
        msg1="Why?\t\t $str1";
    fi;
    if [ "$str2" ]; then
        msg2="Name:\t\t $str2";
    fi;
    print_color 31 "$msg0";
    echo -e "\t$msg1";
    echo -e "\t$msg2";
    echo;
    print_line;
    /usr/bin/flite "$str1";

    print_stack $stack_index

    exiting
    
}

######## ASSERTION
export -f assert_file_not_empty
########
export -f print_func

export -f print_line
export -f print_color
export -f print_color_n
export -f reason_of_death
export -f print_stack
export -f every
export -f random
export -f update_clipboard
export -f trace 
#export -f breakpoint_line
#assertEquals='assertEquals ${FUNCNAME} ${LINENO}'
#alias breakpoint_line='breakpoint_line ${FUNCNAME} ${LINENO}'
export -f breakpoint_line

export -f exiting
#alias breakpoint_line="breakpoint_line  ${FUNCNAME} ${LINENO}"
alias basicE="vi  $dir_breath/basic_of_basics.cfg"
alias reasonE="vi  $dir_breath/basic_of_basics.cfg"
export -f remove_trailing
