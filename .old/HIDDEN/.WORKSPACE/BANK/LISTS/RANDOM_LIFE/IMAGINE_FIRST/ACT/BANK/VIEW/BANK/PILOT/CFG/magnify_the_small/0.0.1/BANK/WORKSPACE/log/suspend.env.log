dir_library=/home/dao04/JAIL/TREE/works/library/0.0.2
LESS_TERMCAP_mb=[01;31m
SSH_AGENT_PID=29636
GXMESSAGE=-sticky -ontop
file_aliases=/home/dao04/JAIL/TREE/works/library/0.0.2/src/rc/cfg/breathing/file_aliases_dynamic.cfg
time=11_00_33
LESS_TERMCAP_md=[01;37m
LESS_TERMCAP_me=[0m
GPG_AGENT_INFO=/home/dao04/.cache/keyring-lLnNH1/gpg:0:1
GLADE_PIXMAP_PATH=:
TERM=xterm
SHELL=/bin/bash
XDG_MENU_PREFIX=xfce-
single_sh=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles/single.sh
XDG_SESSION_COOKIE=747cb34ec7e2320b881a0f4d52d91185-1395213566.740976-1762854624
dir_workspace=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/WORKSPACE
dir_singles_cli=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles_cli
TIMEOUT_PRESENT_FILE=1
WINDOWID=65011716
dir_old_cfg=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/OLD/cfg
LESS_TERMCAP_ue=[0m
file_out=/tmp/out
dir_root=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1
USER=dao04
file_logger=/home/dao04/JAIL/TREE/works/library/0.0.2/src/rc/cfg/breathing/logger.txt
NAME=ofer
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lz=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:
TIMEOUT_RAINBOW=1
dir_lists=/home/dao04/JAIL/TREE/works/LISTS
dir_indicator=/tmp/CRONING/INDICATORS
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session4
GLADE_MODULE_PATH=:
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
delay=1
SOUND=true
SSH_AUTH_SOCK=/home/dao04/.cache/keyring-lLnNH1/ssh
dir_koans=/home/dao04/JAIL/TREE/vendor/0.0.1/bash_koans
dir_old_sh=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/OLD/sh
SESSION_MANAGER=local/localhost:@/tmp/.ICE-unix/29656,unix/localhost:/tmp/.ICE-unix/29656
file_err=/tmp/err
dir_vendor=/home/dao04/JAIL/TREE/vendor/0.0.1
LESS_TERMCAP_us=[01;32m
XDG_CONFIG_DIRS=/etc/xdg
dir_imagine_first=/home/dao04/JAIL/TREE/works/imagine_first/0.0.1
ln_desktop=/home/dao04/Desktop/ROUNDS
GMAIL_USER_BASHRC=advance.linux2
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
DESKTOP_SESSION=lightdm-xsession
dir_breath=/home/dao04/JAIL/TREE/works/breath/0.0.1
file_skip=/home/dao04/JAIL/TREE/works/library/0.0.2/src/rc/cfg/breathing/skip.txt
translate_sh=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles/translation/translation.sh
PWD=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles
BASH_GUI=true
dir_breathing=/home/dao04/JAIL/TREE/works/library/0.0.2/src/rc/cfg/breathing
editor=vim
GNOME_KEYRING_PID=29589
LANG=en_US.UTF-8
dir_singles=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles
dir_magnify=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1
GDMSESSION=lightdm-xsession
file_plan=/home/dao04/JAIL/TREE/plan.txt
dir_croning=/home/dao04/JAIL/TREE/works/croning/0.0.1
SHLVL=7
HOME=/home/dao04
dir_lister=/home/dao04/JAIL/TREE/works/LISTS/bin/TOOLS/lister/0.0.1
dir_log=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/.LOG
TIMEOUT_FILE_EDITING=5
GMAIL_USER_PASSWORD=advance.linux
dir_wrapper=/home/dao04/JAIL/TREE/works/LISTS/bin/TOOLS/wrapper/0.0.1
LOGNAME=dao04
LESS_TERMCAP_so=[01;44;33m
XDG_DATA_DIRS=/usr/local/share:/usr/share
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-MUyxt7E2QJ,guid=43402ba8c581dbe6c8d8ea65532944ff
dir_works=/home/dao04/JAIL/TREE/works
dir_coverage=/home/dao04/JAIL/TREE/works/LISTS/bin/TOOLS/coverage/0.0.1
suspend_sh=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles/suspend/suspend.sh
single_cli_sh=/home/dao04/JAIL/TREE/works/magnify_the_small/0.0.1/singles_cli/single_cli.sh
GUI=true
DISPLAY=:1.0
GLADE_CATALOG_PATH=:
LIBGLADE_MODULE_PATH=:
today=03_19_14
LESS_TERMCAP_se=[0m
COLORTERM=Terminal
XAUTHORITY=/home/dao04/.Xauthority
assertEquals=() {  echo "args: $@";
 cmd="$BASH_ALIASES                $BASH_COMMAND                $BASH_REMATCH                $BASH_VERSION $BASH_ARGC                   $BASH_COMPLETION_COMPAT_DIR  $BASH_SOURCE                  $BASH_ARGV                   $BASH_GUI                    $BASH_SUBSHELL               $BASH_CMDS                   $BASH_LINENO                 $BASH_VERSINFO  ";
 sleep 3;
 str3="$1";
 str4="$2";
 local num3=$(echo "$str3" | wc -c);
 local num4=$(echo "$str4" | wc -c);
 if [ $num3 -gt 100 ]; then
 echo 'too many chars';
 fi;
 if [ $num4 -gt 100 ]; then
 echo 'too many chars';
 fi;
 if [ "$str3" = "$str4" ]; then
 echo '[OK]';
 else
 print_color 31 ERROR;
 echo "expected:|$str3|";
 echo "got:     |$str4|";
 cmd="$editor $file_test +$2";
 update_clipboard "$cmd";
 fi
}
remove_trailing=() {  trace 'remove_trailing';
 local res=$(echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g');
 echo "$res"
}
load_txt=() {  file="$1";
 if [ -f "$file" ]; then
 str0=$(basename $file);
 str=$(higher "$str0");
 aliasing_file $file;
 print_file "$file" 1;
 else
 reason_of_death 'no such file' "$file";
 fi
}
sourcing=() {  file="$1";
 assert_file_exist "$file";
 trace "sourcing $file";
 aliasing_file $file;
 source $file
}
print_rainbow_file=() {  file=$1;
 cleaner_file "$file";
 file=$file_tmp;
 while read line; do
 random 7;
 let "counter=31+$?";
 print_color "${counter}" "$line";
 sleep $TIMEOUT_RAINBOW;
 done < $file
}
breakpoint=() {  print_func;
 flite -t 'error';
 notify-send "$0";
 gxmessage -title 'local Breakpoint' "$0"
}
skip=() {  echo "$@" >> $file_skip
}
wrap_sh=() {  script=$1;
 cmd="vi $script";
 update_clipboard "$cmd";
 print_func;
 echo;
 echo;
 eval "$script" >> $file_out 2>> $file_err;
 res=$?;
 echo '[RESULTS]';
 if [ "$res" -eq 0 ]; then
 cat1 $file_out;
 else
 cat1 $file_err;
 parse_error_line $file_err;
 fi;
 echo
}
print_color_n=() {  echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_rainbow_line=() {  line=$1;
 file=/tmp/empty;
 echo "$line" > $file;
 echo "$line" >> $file;
 echo "$line" >> $file;
 echo "$line" >> $file;
 echo "$line" >> $file;
 let 'counter=1';
 while read line; do
 num=$1;
 let "sum=30+$counter";
 if [ $counter -lt 7 ]; then
 print_color "3${counter}" "$line";
 else
 echo -e "$counter)\t$line";
 fi;
 let "counter+=1";
 done < $file
}
every=() {  local num=${1:-5};
 local cmd_do="$2";
 local cmd_else=${3:-''};
 random $num;
 local res=$?;
 if [ $res -eq 0 ]; then
 notify-send "life is random! :)" "1/$num";
 eval "$cmd_do";
 else
 eval "$cmd_else";
 fi
}
remind_test=() {  print_func;
 echo 'run test.sh'
}
zenity1=() {  TIMEOUT_ZENITY=20;
 local file="$1";
 local title=${2:-"title"};
 local text=${3:-"text"};
 cat $file;
 sleep 6;
 local res=$(cat $file | zenity --list --title "$file" --text "$text" --column "Files" --editable --timeout $TIMEOUT_ZENITY);
 local notify1=$(cat $file | head -1);
 notify-send "$notify1";
 echo "$res"
}
str_to_arr=() {  local str="$1";
 local delimeter=${2-'.'};
 IFS=$delimeter read -a arr <<< "$str"
}
trace=() {  echo "$@" > /dev/null
}
assert_number_in_range=() {  num=$1;
 max=$2;
 if [ $num -lt $max ]; then
 trace ok;
 else
 reason_of_death 'number is not in range' "$num / $max";
 fi
}
breakpoint_line=() {  line=${1:-''};
 print_line;
 print_line;
 print_color 33 "[BREAKPOINT ON LINE x HAS BEEN SET]";
 cmd="vi $0 +$line";
 update_clipboard "$cmd";
 print_line;
 print_line
}
traverse_dir=() {  dir=$1;
 if [ -d "$dir" ]; then
 items=$(ls  "$dir");
 for item in $items;
 do
 notify-send "$item";
 done;
 else
 reason_of_death 'invalid dir' "$dir";
 fi
}
print_func=() {  num=${1:-1};
 echo "---> ${FUNCNAME[${num}]}()"
}
assert_string_not_empty=() {  str="$1";
 if [ -n "$str" ]; then
 num=$( echo "$str" | wc -c );
 trace 'string has X chars:' "$num";
 else
 reason_of_death 'string is empty';
 fi
}
random=() {  local num=$1;
 let "r = $RANDOM % $num";
 return $r
}
assert_dir_exist=() {  dir=$1;
 assert_string_not_empty "$dir";
 if [ -d "$dir" ]; then
 trace 'dir exist' "$dir";
 else
 reason_of_death 'directory not exist' "$dir";
 fi
}
assert_file_exist=() {  file="$1";
 assert_string_not_empty "$file";
 if [ -f "$file" ]; then
 trace 'file exist' "$file";
 else
 reason_of_death 'file not exist' "$file";
 fi
}
print_stack=() {  echo;
 echo;
 print_line;
 print_func;
 print_line;
 echo;
 set +o nounset;
 echo -n '[STACK]';
 local num=${1:-0};
 echo "$num";
 max="${#FUNCNAME[@]}";
 echo "max funcs: $max";
 if [ $num -le $max ]; then
 local caller="${FUNCNAME[$num]}";
 local lineno="${BASH_LINENO[$num-1]}";
 local filename="${BASH_SOURCE[$num]}";
 echo "[ CALL ][$num][$caller]: $filename";
 else
 reason_of_death "stack length is: $max";
 fi;
 exiting
}
scrap_smart_quote=() {  echo;
 print_func
}
assert_cmd_is_valid=() {  cmd="$1";
 $(type "$cmd") > /dev/null;
 res=$?;
 if [ $res -eq 0 ]; then
 trace 'command is valid' "$cmd";
 else
 reason_of_death 'invalid command' "$cmd";
 fi
}
warning=() {  print_func 31;
 echo "$@"
}
cat1=() {  util=/bin/cat;
 file=$1;
 file_tmp=/tmp/file_tmp;
 grep -v '^#' $file | grep -v '^$' > $file_tmp;
 echo $file;
 if [ $# -eq 1 ]; then
 $util $file;
 else
 delay=$2;
 while read line; do
 echo "$line";
 sleep2 $delay;
 done < $file_tmp;
 fi
}
print_color=() {  echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_line=() {  hr='----------------------------------------------------------------';
 printf '%s' "${hr:0:${COLUMNS:-$(tput cols)}}";
 echo
}
exiting=() {  print_color_n 31 '__';
 exit 1
}
print_layout=() {  print_func;
 tree $dir_singles -L 1
}
returning=() {  return
}
exporting=() {  print_func;
 export_name=$1;
 something=$2;
 if [ -d "$something" ]; then
 dir=$something;
 echo "$export_name";
 assert_dir_exist "$dir";
 cmd="export $export_name=$dir";
 trace "$cmd";
 echo "$cmd" >> $file_logger;
 eval "$cmd";
 aliasing_dir "$export_name";
 else
 file=$something;
 assert_file_exist "$file";
 cmd="export $export_name=$file";
 trace "$cmd";
 echo "$cmd" >> $file_logger;
 eval "$cmd";
 aliasing_file "$export_name";
 fi
}
present_file=() {  print_func;
 file="$1";
 offset=${2:-0};
 $(    random 2 );
 local res=$?;
 let "delay=$res";
 echo "delay: $delay";
 if [ -f "$file" ]; then
 cmd="vi $file";
 update_clipboard "$cmd";
 echo;
 filename=$(basename $file);
 str=$(higher $filename);
 echo -ne "[ $str ]\t";
 if [ $offset -eq 0 ]; then
 echo;
 print_line;
 cat1 $file $delay;
 echo;
 else
 if [ $offset -gt 0 ]; then
 cat $file | head -"${offset}";
 else
 cat $file | tail -"${offset}";
 fi;
 fi;
 else
 reason_of_death 'not a file' "$file";
 fi
}
cleaner_file=() {  file=$1;
 file_tmp=/tmp/cleaner_file;
 grep -v '^#' $file | grep -v '^$' > $file_tmp
}
higher=() {  echo ${@^^}
}
print_script=() {  name="$0";
 str=$(higher "$name");
 color=${1:-32};
 print_color_n $color "[ $str ]\t"
}
assert_file_not_empty=() {  echo;
 file="$1";
 if [ -s "$file" ]; then
 echo 'file: passed the indication: -s' "$file";
 else
 reason_of_death 'file is empty' "$file";
 fi;
 res=$( du $file | cut -d' ' -f1 );
 if [ "$res" = 0 ]; then
 echo 'file has content: ' "$file";
 else
 reason_of_death 'file size is 0' "$file";
 fi;
 sleep 10
}
reason_of_death=() {  echo "script: $0";
 print_func 2;
 print_func;
 why="${1:-''}";
 who="${2:-''}";
 echo "why: $why";
 echo "who: $who";
 gxmessage "why:$why|  who:$who" -title 'reason of death';
 exit 1
}
parse_error_line=() {  print_func;
 something="$@";
 if [ -f $something ]; then
 file=$something;
 assert_file_not_empty "$file";
 line=$(cat $file);
 else
 echo 'I have got a line!';
 line=$something;
 fi;
 assert_file_not_empty "$file";
 sleep 10;
 echo "$line";
 arr=();
 str_to_arr "$line" ':';
 max="${#arr[@]}";
 if [ "$max" -gt 1 ]; then
 echo;
 echo '[DETAILS]';
 echo "file:" "${arr[0]}";
 echo "line:" "${arr[1]}";
 echo "msg:" "${arr[2]}";
 echo;
 str_line=$(echo "${arr[1]}" | sed 's/line//g'| sed 's/ //g');
 str_file="${arr[0]}";
 str_command="${arr[2]}";
 str_msg="${arr[3]}";
 cmd="vi $str_file +$str_line";
 notify-send "$str_command" "$str_msg";
 update_clipboard "$cmd";
 else
 reason_of_death 'incorrect parsing of line' "$file";
 fi
}
update_clipboard=() {  notify-send 'update the clipboard' 'croning.sh';
 echo "$1" | /usr/bin/xsel --clipboard
}
clear=() {  print_func;
 sleep 1;
 echo -n '.';
 /usr/bin/clear
}
_=/usr/bin/env
