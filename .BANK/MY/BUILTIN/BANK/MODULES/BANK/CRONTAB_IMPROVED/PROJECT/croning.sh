#!/bin/bash 

dir_self=`dirname $0`
pushd "$dir_self">/dev/null
trap_err(){
    local    str_caller=`caller`
    print_func
    local cmd1="gvim +${str_caller}"
    #proxy update_clipboard "$cmd"
    print_line
    cat /tmp/err
    print_line
    echo "$cmd1"
    print_line
    local    cmd=$( gxmessage -file /tmp/err -entrytext "$cmd1" )
    eval "$cmd"
    exit 0
}
ensure_escaped () 
{ 
    local str="$@";
    local str1=$( echo "$str" | sed 's/"/\\"/g' );
    ( echo "$str1" | grep '\\\\' > /dev/null );
    local res=$?;
    if [ $res -eq 0 ]; then
        echo "$str";
    else
        echo "$str1";
    fi
}

proxy () 
{ 
    local str_caller=`caller`;
    local args=($@);
    local runner="${args[0]}";
    local mode_mute="${MODE_MUTE:-false}";
    type "$runner" > /dev/null || { 
    print_line;
    print_color 31 "[ERROR] command not found: $runner";
    print_line;
#    go_home
    exit
};
local cmd="${args[@]}";
cmd=$( ensure_escaped "$cmd" );
if [ "$mode_mute" = false ]; then
    eval "$cmd" 2> /tmp/err || cat /tmp/err;
else
    eval "$cmd" > /tmp/out 2> /tmp/err || cat /tmp/err;
fi
}


#echo "$@" >> $log_wrapper.txt
################################## start
#num="${1:-1}"
#notify-send "croning choose:" " $num"
#sleep "$num"
#########################################
step(){
    str=$1
    print_color 34 "\t\t\t\t [ $count_step ] $str  "
    proxy "$str" 
    let 'count_step += 1'
}
steps(){
    #    proxy reset_log
    ################am I root?
    step set_user

    ################set global vars / list.txt can use it
    step    exports

    ################ load cron's env dump
    step drop_env

    ################ show error generated by the cron service
    step  run 
}

export choose=${1:-0}
exec 2>/tmp/err
trap trap_err ERR
set -o nounset

clear

count_step=0
#type steps | grep step | sed 's/step//g' | sed 's/;//g'
echo  "[RUNNING]"

source $dir_self/setup.cfg
proxy steps
popd>/dev/null
#cat -n list.txt
