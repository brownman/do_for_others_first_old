#!/bin/bash 
#| |__  _   _(_) | |_     (_)_ __  
#| '_ \| | | | | | __|____| | '_ \ 
#| |_) | |_| | | | ||_____| | | | |
#|_.__/ \__,_|_|_|\__|    |_|_| |_|

######################
#built-ins:
# publish as you play - integrated screencast
# translate the output of a task - translate()
# xcowsay - count the rounds
######################
#depend_package: xcowsay yad
progress_bar(){
    local sec=${1:-60}
    local title=Focus
    local min=$((sec/60))
    #  local time2='later'
    #$(get_time "$sec")

    #    text="$date1-$time2::
    text="${2:-}"
    text="${min}m :: $text"
    title=" $title "
    local num=0
    ( 
    trace "sleep ${sec}s"
    for (( c=1; c<=$sec; c++ ))
    do  
        #tracen  "$c "
        num=$((c*100/sec))
        #assert_equal_str "$num"
        echo "$num" ;            /bin/sleep 1
    done
    ) | yad --progress --percentage=10 \
        --progress-text="$text" \
        --title="$title" \
        --sticky --on-top \
        --auto-close
}

trap_err(){
    #depand_package: vim-gtk gxmessage
    #depand_func: print_line print_func
    str_caller=`caller`
    print_func
    cat /tmp/err
    cmd="gvim +${str_caller}"
cmd1=$( gxmessage -entrytext "$cmd" -file /tmp/err -title 'trap_err' )
eval "$cmd1"
    exit 0
}

translate_line(){
    local line="$1"
    if [ -n "$line" ];then
        echo 'translating' "$line"
        cmd="$script_translate $lang $line"
        echo "[request translation] $cmd"
        eval "$cmd"
    fi
}

print_line(){
    echo '------------'
}
print_func () 
{ 
    echo "${FUNCNAME[1]}"
}

random_line () 
{ 
    local file=$1;
    if [ -f $file ]; then
        local num=$(       cat $file | wc -l );
        local str=$(cat $file | tail -${num} | head -1);
        echo "$str";
    else
        echo 'file not found: ' "$file";
    fi
}


proxy () 
{ 
    local str_caller=`caller`;
    local args=($@);
    local runner="${args[0]}";
    local mode_mute="${MODE_MUTE:-false}";
    type "$runner" > /dev/null || { 
        print_line;
        print_color 31 "[ERROR] command not found: $runner";
        print_line;
        go_home
    };
    local cmd="${args[@]}";
    cmd=$( ensure_escaped "$cmd" );
    if [ "$mode_mute" = false ]; then
        eval "$cmd" 2> /tmp/err || cat /tmp/err;
    else
        eval "$cmd" > /tmp/out 2> /tmp/err || cat /tmp/err;
    fi
}
ensure_escaped () 
{ 
    local str="$@";
    local str1=$( echo "$str" | sed 's/"/\\"/g' );
    ( echo "$str1" | grep '\\\\' > /dev/null );
    local res=$?;
    if [ $res -eq 0 ]; then
        echo "$str";
    else
        echo "$str1";
    fi
}
print_func () 
{ 
    echo "${FUNCNAME[1]}"
}
print_color () 
{ 
    local color=${1:-34};
    shift;
    local str="${@:-X}";
    echo -e "\x1B[01;${color}m[*]\x1B[0m $str"
}
update_clipboard () 
{ 
    local args=($@);
    local cmd="${args[@]}";
    proxy present print_color 33 "[CLIPBOARD] $cmd";
    local mode_debug=${MODE_DEBUG:-false};
    if [ $mode_debug = true ]; then
        local str=$( gxmessage 'update clipboard' -entrytext "$cmd"  );
        echo "$str" | xsel --clipboard;
    else
        echo "$cmd" | xsel --clipboard;
    fi;
    proxy sleep 1
}
print_color () 
{ 
    local color=${1:-34};
    shift;
    local str="${@:-X}";
    echo -e "\x1B[01;${color}m[*]\x1B[0m $str"
}
update_clipboard () 
{ 
    local args=($@);
    local cmd="${args[@]}";
    proxy present print_color 33 "[CLIPBOARD] $cmd";
    local mode_debug=${MODE_DEBUG:-false};
    if [ $mode_debug = true ]; then
        local str=$( gxmessage 'update clipboard' -entrytext "$cmd"  );
        echo "$str" | xsel --clipboard;
    else
        echo "$cmd" | xsel --clipboard;
    fi;
    proxy sleep 1
}
export -f progress_bar
export -f update_clipboard
export -f random_line
export -f trap_err
export -f print_color
export -f print_func
export -f translate_line
export -f proxy
export -f ensure_escaped
export -f trap_err
