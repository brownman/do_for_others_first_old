back_home(){
    echo '[BACK HOME]'
    if [ $0 = bash ];then
        #    return 1
        exit 1
    else
        exit 1
    fi

}
present_file(){
    print_file $1
}
print_file(){
    file=$1
    echo $file
    cat $file
}
update_file(){
    counter_step=${counter_steps:-0}
    let 'counter_steps+=1'
    #info: fallback mode - update the logger 
    local    args=(  "$@" )
    local   cmd="$counter_steps: ${args[@]}"
    ( type update_file01 2>/dev/null )
    local res=$?
    if [ "$res" -eq 0  ];then
        update_file01 "$cmd"
    else
        echo "$cmd" >> $file_logger
    fi
}

robot(){
    #info: print to screen or to a file
    local    args=(  "$@" )
    local   cmd="${args[@]}"
    type robot01 2>/dev/null 
    local res=$?
    #        echo "robot01 exist?  $res"
    if [ "$res" -eq 0  ];then
        robot01 "$cmd"
    else
        update_file "$cmd"
    fi

}
proxy(){
    #info: proxy every command
    local    args=(  "$@" )
    local   cmd="${args[@]}"
    (    type proxy01 2>/dev/null )
    local res=$?
    #        echo "proxy01 exist?  $res"
    if [ "$res" -eq 0  ];then
        proxy01 "$cmd"
    else
        robot "$cmd"
        ( eval "$cmd" 1>/dev/null 2>/dev/null )
        res=$?
        if [ "$res"  -eq 0 ];then
            eval "$cmd"
        else
            echo "[ FAILED ] $cmd" 
            sleep 3
            back_home
        fi
    fi

}

echo(){
    #info: like we should
    #check: type echo
    local   util=/bin/echo
    local    args=( "$@" )
    local cmd="${args[@]}"
    $util "$@" >> ${file_echo:-dir_tmp/echo}
    eval "$util $cmd"
}
export -f back_home
export -f present_file
export -f print_file
export -f update_file
export -f robot
export -f proxy
export -f echo

