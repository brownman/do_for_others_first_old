#!/bin/bash
#vim: respect
#vim_remind: set filetype=sh
#vim_remind: failed:set filetype=bash
#vim identation: gg=G


#set -e
shopt -s expand_aliases
reset
pushd `dirname $BASH_SOURCE`>/dev/null
trap 'trap_err' ERR
export cmd_to_exit="return"
export -f trap_err






print_shlvl(){
    echo "SHLVL: $SHLVL"
    sleep 2
}
update_clipboard(){
    echo "$@" | xsel --clipboard
}
trap_err(){
    #print_shlvl
    echo "[TRAP] $?"
    local str_caller=`    caller`
    local cmd="vi +${str_caller}"
    proxy "update_clipboard \"$cmd\""
    #        return 0
    proxy "$cmd_to_exit"
}



go_home(){
    if [ $0 = bash ];then
        echo returning
        return
    else
        echo exiting
        exit 1
    fi
}


proxy(){
            local args=( $@ )
            local runner=${args[0]}
 type $runner 2>/dev/null || { echo "[ERROR] command not found: $runner";}
            local cmd="${args[@]}"

            local max="${#args[@]}"
            #echo "PROXY ($max): $cmd"
            echo "$cmd" >> /tmp/proxy
            eval "$cmd" 
}
install_trap(){
    echo
}
#info:   first list
#pending

export VERBOSE=true
#export PRESENT=screen
export PRESENT=normal

run_dir(){
    echo -n "[ run_dir] "
    echo $dir
    local dir=$1
    local dir_self=$(where_am_i)
    #  local dir_self=$( echo `dir_self` )
    #`dirname $BASH_SOURCE`
    #   ls $dir_self/$dir/breath.cfg 
    if [ -d "$dir_self/$dir" ];then

        file="source $dir_self/$dir/breath.cfg"
        [ -f "$file" ] && { source $file;} || { echo 'file not found' "$file";return 0 ;}

    else
        echo "no such dir:" "$dir_self/$dir" 
        sdflkj
        return 1
    fi 

}
presenting_is_based_on_verbosity_level(){
    local desc="$1"
    local dir="$2"


    case "$PRESENT" in
        normal)
            echo "[ desc ] $desc"
            echo "[ dir ]  $dir" 
            ;;
        short)
            echo short

            ;;

        screen)

            clear
            echo "[desc] $desc"
            toilet --gay "$dir"
            sleep 2

            ;;
        empty)
            if test "x`pidof $bash`" != x; then
                echo                stop it
            fi
            ;;
            #   echo $"Usage: $0 {start|stop|restart|condrestart|status}"
            #           return
            #      *)
    esac
    ##################### and do!
    run_dir "$dir"
}
where_am_i(){
    ########### method1
    #use: /bin/readline
    local  rpath=$(readlink -m "$BASH_SOURCE")
    local   rcommand=${rpath##*/}
    local  str_res=${rpath%/*}
    ########### method2
    #use:bash builtin: caller
    #
    #local rpath=$( caller | cut -d' ' -f2 | xargs dirname )

    local  dir_self="$( cd $str_res  && pwd )"
    echo "$dir_self"
}
just(){
    echo -n "[JUST] " 
    echo "$@"
    return 0
}

backup_proxy(){
    echo "[BACKUP PROXY]"

    local cmd="cowsay 'backup proxy'"
    proxy "$cmd"
    file=/tmp/proxy
    file_old=/tmp/proxy.old

    if [ -f  $file ];then
        if [ -f  $file_old ];then
            cmp $file $file_old
            local    res=$? 
            if [ $res -eq 1 ];then
                echo you made some progress
                echo making a backup..
                mv $file $file_old
            else 
                echo files are identical
                echo tip: use command: testing
            fi
        else
            mv $file $file_old
        fi
        sleep 2
    else
        echo 'file not found: ' "$file"
    fi
    sleep 3
}


steps(){
    #print_shlvl

    backup_proxy
    #install_trap
    local dir_self=$( where_am_i )
    #local dir_self="$rpath"
    #$( dir_self )
    #$( dirname $BASH_SOURCE )

    local file_list=$dir_self/list.txt

    just "$file_list"
    local desc=''
    local dir=''
    while read line;do
        if [ -n "$line" ];then

            desc=$( echo "$line" | cut -d'|' -f1 )
            dir=$( echo "$line" | cut -d'|' -f2 )
            presenting_is_based_on_verbosity_level "$desc" "$dir"
        else
            return
        fi
    done <"$file_list"



}


#print_shlvl
steps
popd>/dev/null
