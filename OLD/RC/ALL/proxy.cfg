#set -o nounset
alias proxyE="vi $BASH_SOURCE"
proxy () 
{ 
    local args=("$@");
    local cmd="${args[@]}";
    local base=`basename $BASH_SOURCE`;
    local msg="[$base] [cmd] [ $cmd ]"
    echo "$msg" >> /tmp/proxy;
    trace "$msg"
    ( eval "$cmd" ) > /dev/null 2> /dev/null;
    local res=$?;
    if [ "$res" -eq 0 ]; then
        eval "$cmd";
    else
        echo "[warning][code:$res]" >> /tmp/proxy;
        go_home
    fi
}

random () 
{ 
    local num=$1;
    let "r = $RANDOM % $num";
    return $r
}

every () 
{ 
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};
    local res=0
    if [ $num -eq 0 ];then
        res=0
    else
        random $num;
    fi
    res=$?;
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "boom/$num";
        eval "$cmd_do";
    else
        eval "$cmd_else";
    fi
}
sleep(){
    local num=$1
    if [ "$DEBUG" = true ];then
        print_color_n 31 '[Zzzz] '
        echo "$num"
        /bin/sleep $num
    else
        proxy "debug false -> skip sleeping"
    fi

}


breaking(){
    echo ' [ breaking ]'
    break
}
go_home () 
{ 
    echo '[GO HOME]'
    if [ $0 = 'bash' ]; then
        echo 'bash -> returning';
        return 1;
    else
        echo 'script -> exiting';
        exit 1;
    fi
}

function error_exit {
    local exit_code=$?
local msg="$1"    

echo -n "[ Exit_code: $exit_code ]"
local cmd="print_color 31  \"$msg\""
proxy "$cmd"

case $msg in
    SIGHUP)
        set +o nounset
        ;;
    SIGTERM)
        set +o nounset
        ;;
    SIGERR)
        echo 
        local file="${BASH_SOURCE[1]}"
        echo 
        local line="${BASH_LINENO[0]}"
        local cmd="vi $file +$line"
        update_clipboard "$cmd"
       # echo "$0"
#        echo "$LINENO"
       # echo "$BASH_LINENO"
        go_home
        cat /tmp/proxy
        set +o nounset
        ;;
    SIGINT)

        cat /tmp/proxy
        go_home
        set +o nounset

        #breaking
        ;;
esac
#trace exit 1
#eval    go_home
}
#Trap the killer signals so that we can exit with a good message.
trap "error_exit 'SIGHUP'" SIGHUP
trap "error_exit 'SIGINT'" SIGINT
trap "error_exit 'SIGTERM'" SIGTERM
trap "error_exit 'SIGERR'" ERR

broadcast(){
    proxy 'echo BROADCASTING'
local str="$@"
xcowsay "$str" &
notify-send "$str" &
flite -t "$str" &
}
trace(){
    local verbose="${VERBOSE:-true}"
    if [ "$verbose" =  true ];then
       print_color 33 "[TRACE] $@" 
            fi
    }

export -f proxy
export -f breaking
export -f error_exit 
export -f go_home
export -f random
export -f every
export -f broadcast
export -f trace
#set +o nounset
