   echo '[FUNCS.CFG] loaded through .bashrc'
   alias funcsE="vi $BASH_SOURCE"
   translate(){
#       http://www.commandlinefu.com/commands/matching/translate/dHJhbnNsYXRl/sort-by-votes
       wget -qO- "http://ajax.googleapis.com/ajax/services/language/translate?v=1.0&q=$1&langpair=$2|${3:-en}" | sed 's/.*"translatedText":"\([^"]*\)".*}/\1\n/'; } 
go_home(){
    local cmd_to_source_exit='return 0'
    local cmd_to_script_exit='exit 1'
    print_color_n 32 '[GO_HOME]'
        local file="$BASH_SOURCE"
        if [ "$file" = bash ];then
                eval "$cmd_to_source_exit"
        else
                eval "$cmd_to_script_exit"
                fi
}


pv(){
    local util=`which pv`
        cmd="echo \"$@\" | \"$util\" -qL 10"
        proxy "$cmd"
}

print_color () 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n () 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}





print_shlvl(){
    echo "SHLVL: $SHLVL"
        proxy sleep 2
}
update_clipboard(){
#print_shlvl
    local args=( $@ )
local cmd="${args[@]}"
    print_color 33 "[CLIPBOARD] $cmd"
   #     local str_caller=`    caller`
   #     local cmd="echo $str;vi +${str_caller}"

        proxy "notify-send 'update clipboard' '$cmd' "
        echo "$cmd" | xsel --clipboard
}



proxy(){
    local args=( $@ )
        local runner="${args[0]}"
        type "$runner" 1>/dev/null 2>/dev/null || { echo "[ERROR] command not found: $runner"; proxy go_home; }
    local cmd="${args[@]}"
        local str_caller=`caller`
        local max="${#args[@]}"
        local verbose=${VERBOSE:-false}
        if [ "$verbose" =  true ];then
echo "PROXY ($max): $cmd"
fi
        echo "vi +$str_caller # $cmd" >> /tmp/proxy
        eval "$cmd" 
}
#info:   first list
#pending

run_dir(){
    echo -n "[ run_dir] "
        echo $dir
        local dir0="$1"
        local dir=`echo "$dir0"`
#local dir_self=$(where_am_i)
#  local dir_self=$( echo `dir_self` )
#`dirname $BASH_SOURCE`

        if [ -d "$dir" ];then
            print_color 34 "[RUN_DIR] $dir";

    local            file="$dir/breath.cfg"
        [ -f "$file" ] && { source $file; } || { echo 'file not found' "$file";return 0 ; }
        else
            echo "no such dir:" "=_${dir}_=" 
                proxy       go_home 
                fi 
                proxy sleep 5
}
callers(){
    print_color 35 '[callers]'
    present1 figlet CALLERS
    local count=0
    local res=0
    local max="${#BASH_LINENO[@]}"
    let 'max-=1'
    while [ "$count" -lt  "$max" ];do
        echo -n "$count of $max : "
local str_caller=$( caller "$count" )
#if [ "$str_callers" = '' ];then
#    break
#    else
        echo "vi +${str_caller}" 2>/dev/null
#    fi

        let 'count+=1'
        done
    }

present(){

    local type=$1
   # :-$MODE_PRESENT}
    local desc="$2"
    local desc2="${3:-''}"

#local mode_translate=${MODE_TRANSLATE:-false}
#local lang_to=${LANG_TO:-ru}

    case "$type" in
        normal)
            echo "[ desc ] $desc"
            ;;
        figlet)
            proxy "figlet '$desc'"
            proxy sleep 2
            ;;
        notify-send)
        proxy "notify-send '$desc' '$desc2'"
            ;;
        pv)
#clear
            proxy "pv '$desc'"
            ;;
        toilet)
            proxy    "toilet --gay \"$desc\""
            proxy        sleep 2
;;
            *)
proxy "print_color 31 'present $1 not defined '"
            ;;
        esac
#        if [ "$mode_translate" = true ];then
#echo            translate "$lang_target" "$desc"
#            fi
##################### and do!

}
where_am_i(){
########### method1
#use: /bin/readline
#echo caller `    caller`
#echo
#    sleep 2
    local  rpath=$(readlink -m "${BASH_SOURCE[1]}")
        local   rcommand=${rpath##*/}
    local  str_res=${rpath%/*}
########### method2
#use:bash builtin: caller
#local rpath=$( caller | cut -d' ' -f2 | xargs dirname )

local  dir_self="$( cd $str_res  && pwd )"
local cmd="present notify-send 'where_am_i' '$dir_selfr'"
proxy "$cmd"
echo "$dir_self"
}
just(){
print_color 33 "[JUST] " 
echo "$@"
echo   "$cmd_to_exit"
proxy "sleep 2"
eval "$cmd_to_exit"


}
util(){
local runner=$1
shift
local args=( $@ )
eval "$runner ${args[@]}"
}

random() 
{ 
    #    print_func;

    local num=$1
    let "r = $RANDOM % $num";
    return $r
}

every () 
{ 
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};
    if [ -z "$cmd_else" ];then
        cmd_else="robot \"$cmd_do\""
    fi
    local res=0;
    if [ $num -eq 0 ]; then
        res=0;
    else
        random $num;
    fi;
    res=$?;
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "boom/$num";
        eval "$cmd_do";
    else
        eval "$cmd_else";
    fi
}
assert () 
{ 
    #delegate: returnin, exiting 
    local args=("$@");

    #add_test "${args[@]}";
    proxy sleep 1
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            dir_exist)
                [ -d "$item" ] && res=0
                ;;
            file_exist)
                [ -f "$item" ] && res=0
                ;;
            file_has_content)
                [ -s "$item" ] && res=0
                ;;
            string_has_content)
                [ -n "$item" ] && res=0
                ;;
            *)
                robot "assertion not defined yet: $action"

                ;;
        esac;
    else
        robot "supply 2 args: $@";
    fi;

    echo "ASSERT: $res"
    if [ $res -eq 1 ];then
        go_home
    fi
}

#export -f assert

export -f every
export -f random
export -f assert

export -f proxy
export -f go_home
export -f print_color

export -f print_color_n
export -f where_am_i
export -f run_dir
export -f update_clipboard
export -f util
export -f present
export -f callers
export -f pv
export -f translate
alias present1='present'
