if [ $res -eq 1 ]; then
        local str=`echo "$action" | sed 's/_/ /g'`;
        echo proxy flite -t "$str";
        echo 'returning/exiting';
        if [ $0 = "bash" ]; then
            cmd="returning $res";
            echo proxy "$cmd";
        else
            cmd="exiting $res";
            echo proxy "$cmd";
        fi;
    else
        echo '[OK]'
    fi

run_dir(){
    echo -n "[ run_dir] "
        echo $dir
        local dir0="$1"
        local dir=`echo "$dir0"`
#local dir_self=$(where_am_i)
#  local dir_self=$( echo `dir_self` )
#`dirname $BASH_SOURCE`

        if [ -d "$dir" ];then
            print_color 34 "[RUN_DIR] $dir";

    local            file="$dir/breath.cfg"
        [ -f "$file" ] && { source $file; } || { echo 'file not found' "$file";return 0 ; }
        else
            echo "no such dir:" "=_${dir}_=" 
                proxy       go_home 
                fi 
                proxy sleep 5
}
callers(){
    print_color 35 '[callers]'
        present1 figlet CALLERS
        local count=0
        local res=0
        local max="${#BASH_LINENO[@]}"
        let 'max-=1'
        while [ "$count" -lt  "$max" ];do
            echo -n "$count of $max : "
                local str_caller=$( caller "$count" )
#if [ "$str_callers" = '' ];then
#    break
#    else
                echo "vi +${str_caller}" 2>/dev/null
#    fi

                let 'count+=1'
                done
}


       esac
 
    case "$type" in 
    echo)
        /bin/echo $@
    normal)
        echo "$desc"
        ;;
    figlet)
        eval "figlet '$desc'";
    proxy sleep 2
        ;;
    notify-send)
        eval "notify-send '$desc' '$desc2'"
        ;;
    pv)
        eval "pv '$desc'"
        ;;
    toilet)
        eval "toilet --gay \"$desc\"";
    proxy sleep 2
        ;;
    *)
        eval "print_color 31 'present of type: $1 not defined '"
        go_home
        ;;
    esac

read_tag(){
    local file=$1
    local funcs=$2
    local tag=$3
    echo -e "\t\t[ $func ]"
    #alias "$func=\"echo $func\""


    local str=$( cat $file | grep $func -A 1 | grep $tag )
    if [ -n "$str" ];then
        echo -ne "\t\t\t[ $tag ] "
        echo $str
    else 
        echo "[ERROR] empty tag $tag"
        local cmd="vi $file"
        update_clipboard "$cmd"
        proxy go_home
    fi
    #| tail -1 
}

go_home(){
#    cat -n /tmp/proxy | tail -2
    every 5 "echo 'type: logs for watching last proxied commands'"
        local cmd_to_source_exit='return 0'
        local cmd_to_script_exit='exit 1'
        print_color_n 32 '[GO_HOME]'
        local file="$BASH_SOURCE"
        if [ "$file" = bash ];then
            eval "$cmd_to_source_exit"
        else
            eval "$cmd_to_script_exit"
                fi
}

ensure_escaped(){
    local str="$cmd"
    echo "str: $str"
local str1=$( echo "$str" | sed 's/"/\\"/g' ) 
echo "str1: $str1"
    local str2=$(  echo 1>/dev/null "$str1" | grep '\\\\' )  && { echo "$str1"; } || { echo "$str"; }
# echo "$str1" | grep '\\\\'  && { echo "$str1"; } || { echo "$str"; } 
    echo "str2: $str2"
#    echo "$str2"
}

proxy0 () 
{ 
#pending   assert string_is_escaped "$cmd" 
#attention: proxy must not contain calls to itself !!!
   local str_caller=`caller`;

    local args=($@);
    local cmd="${args[@]}";

    local mode_escape=${MODE_ESCAPE:-false};
    if [ "$mode_escape" = true ];then
    cmd=$( ensure_escaped \"$cmd\" )
fi

    local msg="gvim +$str_caller"
    local max="${#args[@]}";

    
    
    local runner="${args[0]}";
    local verbose=${VERBOSE:-false};
    type "$runner" > /dev/null 2> /dev/null || { 
        echo "[ERROR] command not found: $runner";
        go_home
    };
    if [ "$verbose" = true ]; then
        echo "PROXY ($max): $cmd";
    fi;
    echo "$msg: $cmd" >> /tmp/proxy;
 #   echo $msg
# eval "$cmd" 2>/tmp/err || { gxmessage  -timeout 10 -file /tmp/err -entrytext "$msg"; go_home; }
eval "$cmd"
 
}

present() 
{ 
#dont call present() through proxy - it use the proxy itself
    local type=$1;
    shift
        local args=( $@ )
        local cmd="${args[@]}"
        proxy "$type $cmd"
}

proxy () 
{ 
    local str_caller=`caller`;
    local args=($@);
    local runner="${args[0]}";
    local cmd="${args[@]}";
    local max="${#args[@]}";
    local verbose=${VERBOSE:-false};
    type "$runner" > /dev/null 2> /dev/null || { 
    echo 
    msg="[ERROR] command not found: $runner";
    echo "$msg"

echo "vi +$str_caller # $cmd" >> /tmp/proxy;
    echo "$msg" >> /tmp/proxy
    exiting
    #proxy go_home
};


