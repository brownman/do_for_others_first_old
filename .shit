if [ $res -eq 1 ]; then
        local str=`echo "$action" | sed 's/_/ /g'`;
        echo proxy flite -t "$str";
        echo 'returning/exiting';
        if [ $0 = "bash" ]; then
            cmd="returning $res";
            echo proxy "$cmd";
        else
            cmd="exiting $res";
            echo proxy "$cmd";
        fi;
    else
        echo '[OK]'
    fi

run_dir(){
    echo -n "[ run_dir] "
        echo $dir
        local dir0="$1"
        local dir=`echo "$dir0"`
#local dir_self=$(where_am_i)
#  local dir_self=$( echo `dir_self` )
#`dirname $BASH_SOURCE`

        if [ -d "$dir" ];then
            print_color 34 "[RUN_DIR] $dir";

    local            file="$dir/breath.cfg"
        [ -f "$file" ] && { source $file; } || { echo 'file not found' "$file";return 0 ; }
        else
            echo "no such dir:" "=_${dir}_=" 
                proxy       go_home 
                fi 
                proxy sleep 5
}
callers(){
    print_color 35 '[callers]'
        present1 figlet CALLERS
        local count=0
        local res=0
        local max="${#BASH_LINENO[@]}"
        let 'max-=1'
        while [ "$count" -lt  "$max" ];do
            echo -n "$count of $max : "
                local str_caller=$( caller "$count" )
#if [ "$str_callers" = '' ];then
#    break
#    else
                echo "vi +${str_caller}" 2>/dev/null
#    fi

                let 'count+=1'
                done
}


       esac
 
    case "$type" in 
    echo)
        /bin/echo $@
    normal)
        echo "$desc"
        ;;
    figlet)
        eval "figlet '$desc'";
    proxy sleep 2
        ;;
    notify-send)
        eval "notify-send '$desc' '$desc2'"
        ;;
    pv)
        eval "pv '$desc'"
        ;;
    toilet)
        eval "toilet --gay \"$desc\"";
    proxy sleep 2
        ;;
    *)
        eval "print_color 31 'present of type: $1 not defined '"
        go_home
        ;;
    esac

read_tag(){
    local file=$1
    local funcs=$2
    local tag=$3
    echo -e "\t\t[ $func ]"
    #alias "$func=\"echo $func\""


    local str=$( cat $file | grep $func -A 1 | grep $tag )
    if [ -n "$str" ];then
        echo -ne "\t\t\t[ $tag ] "
        echo $str
    else 
        echo "[ERROR] empty tag $tag"
        local cmd="vi $file"
        update_clipboard "$cmd"
        proxy go_home
    fi
    #| tail -1 
}

go_home(){
#    cat -n /tmp/proxy | tail -2
    every 5 "echo 'type: logs for watching last proxied commands'"
        local cmd_to_source_exit='return 0'
        local cmd_to_script_exit='exit 1'
        print_color_n 32 '[GO_HOME]'
        local file="$BASH_SOURCE"
        if [ "$file" = bash ];then
            eval "$cmd_to_source_exit"
        else
            eval "$cmd_to_script_exit"
                fi
}

ensure_escaped(){
    local str="$cmd"
    echo "str: $str"
local str1=$( echo "$str" | sed 's/"/\\"/g' ) 
echo "str1: $str1"
    local str2=$(  echo 1>/dev/null "$str1" | grep '\\\\' )  && { echo "$str1"; } || { echo "$str"; }
# echo "$str1" | grep '\\\\'  && { echo "$str1"; } || { echo "$str"; } 
    echo "str2: $str2"
#    echo "$str2"
}

proxy0 () 
{ 
#pending   assert string_is_escaped "$cmd" 
#attention: proxy must not contain calls to itself !!!
   local str_caller=`caller`;

    local args=($@);
    local cmd="${args[@]}";

    local mode_escape=${MODE_ESCAPE:-false};
    if [ "$mode_escape" = true ];then
    cmd=$( ensure_escaped \"$cmd\" )
fi

    local msg="gvim +$str_caller"
    local max="${#args[@]}";

    
    
    local runner="${args[0]}";
    local verbose=${VERBOSE:-false};
    type "$runner" > /dev/null 2> /dev/null || { 
        echo "[ERROR] command not found: $runner";
        go_home
    };
    if [ "$verbose" = true ]; then
        echo "PROXY ($max): $cmd";
    fi;
    echo "$msg: $cmd" >> /tmp/proxy;
 #   echo $msg
# eval "$cmd" 2>/tmp/err || { gxmessage  -timeout 10 -file /tmp/err -entrytext "$msg"; go_home; }
eval "$cmd"
 
}

present() 
{ 
#dont call present() through proxy - it use the proxy itself
    local type=$1;
    shift
        local args=( $@ )
        local cmd="${args[@]}"
        proxy "$type $cmd"
}

proxy () 
{ 
    local str_caller=`caller`;
    local args=($@);
    local runner="${args[0]}";
    local cmd="${args[@]}";
    local max="${#args[@]}";
    local verbose=${VERBOSE:-false};
    type "$runner" > /dev/null 2> /dev/null || { 
    echo 
    msg="[ERROR] command not found: $runner";
    echo "$msg"

echo "vi +$str_caller # $cmd" >> /tmp/proxy;
    echo "$msg" >> /tmp/proxy
    exiting
    #proxy go_home
};


export dir_zero=~/JAIL/TREE
export dir_root=$dir_root/PROJECT
export dir_bank=$dir_root/BANK
alias cdroot="cd $dir_root"

alias cdroot2="cd $dir_root2"
alias cdsetup="pushd  $dir_root2/SETUP;gvim .;popd"

alias cdmovie="cd ~/JAIL/TREE/ACT/PENDING/3_WORKSPACE/BANK/vikings"
alias cdworkspace="cd $dir_root2/ACT/BANK/WORKSPACE/BANK"
alias cdhotkeys="cd $dir_root2/SETUP/STEP2/BANK/hotkeys_list"
#alias locate="echo try-sudo updatedb && /usr/bin/locate;"
echo "LOADING QUICK.cfg"
shopt -s expand_aliases
#alias quick_robot="$runner_robot"
alias quickE="vi $BASH_SOURCE"
export_funcs(){
#alias pending="pending ${BASH_SOURCE[0]} ${LINENO[0]} ${BASH_LINENO[0]} caller"
    export -f proxy
        export -f go_home
        export -f assert
        export -f print_color

}
reminder(){
#pending export -f print_file
    echo -ne  "[viewS]"
#alias | grep 'cd_\|view\|quick' 
#        alias | grep view --color=auto | cut -d'=' -f1

        local cmd1="alias | grep quick --color=auto | cut -d'=' -f1 > /tmp/quick"
        eval "$cmd1"
        random_line "/tmp/quick"
#local cmd="every 5 \"$cmd1\" \"robot $cmd1\""
#echo "$cmd"
#3        proxy "every 5 '$cmd1'"

}


exports(){
    export dir_root=$dir_root
        export dir_view=$dir_root/view
        export dir_cfg=$dir_root/CFG

        export dir_code=$dir_root/CODE
        export dir_entry=$dir_root/ENTRY_POINTS
        export dir_view=$dir_root/VIEW
        export dir_snippet=$dir_view/scripts/save_your_snippets
        export dir_plugins=$dir_view/projects/plugins/0.0.1
        export dir_tools=$dir_view/TOOLS

        export dir_tools_bank=$dir_tools/BANK
        export dir_library=$dir_tools_bank/library/0.0.1
        export dir_stacker=$dir_tools_bank/stacker/0.0.1
        export dir_coverage=$dir_tools_bank/coverage/0.0.1
        export dir_lister=$dir_tools_bank/lister/0.0.1

        export dir_vendor="$dir_root/VENDOR/0.0.1"
        

}
export_vars(){
    echo
}
aliases(){
#CD
        alias cd_view="cd $dir_view"

        alias cd_tools="cd $dir_tools"
        alias cd_library="cd $dir_library"
#view
        alias view_snippet="source $dir_snippet/breath.cfg"
        alias view_tools="source $dir_tools/breath.cfg"
        alias view_vendor="source $dir_vendor/breath.cfg"
#QUICK
        alias quick_makes_me_happy="cd $dir_view/"
        alias quick_breath="$dir_self/RECENT/breath.cfg"
        alias quick_listE="vi $dir_root/list.txt"
        alias quick_debug="$dir_stacker/debug.sh"
        alias quick_log="echo /tmp/proxy;print_line;cat -n /tmp/proxy | tail -5;echo;echo; echo /tmp/err;print_line; cat -n /tmp/err"

        alias log="echo /tmp/proxy;print_line;cat -n /tmp/proxy | tail -5;echo;echo; echo /tmp/err;print_line; cat -n /tmp/err"
        alias quick_pend="cat /tmp/pending | tail -5"
        alias quick_set1="set +o nounset"
alias tool_lister="$dir_lister/lister.sh"
alias tool_coverage="$dir_coverage/coverage.sh"

alias layout='cd $dir_view'
#alias layoutPendingSource='source $dir_view/breath.cfg'
#alias layoutPendingRun='$dir_view/breath.cfg pending'
#alias layoutTestingSource='source $dir_view/breath.cfg'
alias breath="source ./breath.cfg"
alias quick_bookmark="save"

alias quick_sos="~/JAIL/TREE/VIEW/BANK/PILOT/CFG/magnify_the_small/0.0.1/wrapper.sh bin/0_sos/sos.sh"

alias quick_tasker="~/JAIL/TREE/VIEW/BANK/PILOT/CFG/magnify_the_small/0.0.1/wrapper.sh bin/1_tasker/tasker.sh"
alias quick_genesis="vi $dir_root/genesis.yaml"
alias quick_split="echo source $file; echo alias X or export Y"
#alias runner_debug="vi /home/dao04/JAIL/TREE/VIEW/BANK/TOOLS/BANK/wrapper/0.0.1/BANK/stacker/0.0.1/debug.sh"
#alias runner_debug=~/JAIL/TREE/VIEW/PENDING/WRAPPER/OLD/CFG/CFG1/stacker/0.0.1/debug.sh
#alias runner_debug="/home/dao04/JAIL/TREE/VIEW/BANK/TOOLS/BANK/stacker/0.0.1/debug.sh"
#alias toilet="/usr/bin/toilet --gay"
}
#present(){
#    
#    alias | grep quick --color=auto
#    }

if [ "${FUNCNAME[1]}" = proxy ];then
    proxy present  print_color 31 "assert must be called directly  - not through proxy"
    proxy go_home
fi
    set -e

set_arr_line(){
    arr=()
    print_func
    local    line="$@"
    #sleep 1
    str_to_arr "$line"
    arr_line=( "${arr[@]}" )

    num="${#arr[@]}"

    echo '[LINE]'
    echo "run $num commands on every item from the list"
    echo "---[ ${arr_line[@]} ]---"

    #sleep 2
}

reason_of_death(){
    echo "reason of death"
    echo "why: ${1:-''}"
    echo "who: ${2:-''}"
    echo exiting
    exit
}



        if [ $counter -lt $max ];then
            echo            breaking
            break
        fi

