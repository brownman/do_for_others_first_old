#set -o nounset
alias proxyE="vi $BASH_SOURCE"
print_file(){

    local file=$1
    local max=$2
    echo


    print_color_n 31 "[FILE]"

    echo " $file [ $max ] "
    echo "----"
    echo
    cat $file | tail -${max}
    echo
    echo '---'
    }
proxy () 
{ 
    local args=("$@");
    local cmd="${args[@]}";
if [ "${#BASH_SOURCE[@]}" -gt 1 ];then
    local base=`basename ${BASH_SOURCE[1]}`;
else
    local base=`basename $0`;
fi

    local msg="[$base] [ $cmd ]"
    echo "$msg" >> /tmp/proxy;
    trace "$msg"
        #update_clipboard "$cmd"
    ( eval "$cmd"  1>/dev/null 2>/tmp/err );
   if [ -s "/tmp/err" ];then
       echo '[ERROR FOUND]'
#echo        gxmessage -file /tmp/err -title error -timeout 10
print_file /tmp/err
       go_home
       
   fi
    local res=$?;
    if [ "$res" -eq 0 ]; then
        eval "$cmd";
    else
        echo "[warning][code:$res]" >> /tmp/proxy;
        go_home
    fi
}

random () 
{ 
    local num=$1;
    let "r = $RANDOM % $num";
    return $r
}

every () 
{ 
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};
    local res=0
    if [ $num -eq 0 ];then
        res=0
    else
        random $num;
    fi
    res=$?;
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "boom/$num";
        eval "$cmd_do";
    else
        eval "$cmd_else";
    fi
}
sleep(){
    local num=$1
#    if [ "$DEBUG" = true ];then
        proxy "print_color_n 31 '[Zzzz] '"
        echo "$num"
        /bin/sleep $num
 #   else
  #      proxy "debug false -> skip sleeping"
  #  fi

}


breaking(){
    echo ' [ breaking ]'
    break
}
go_home () 
{ 
    echo '[GO HOME]'
    if [ $0 = 'bash' ]; then
        echo 'bash -> returning';
        return 1;
    else
        echo 'script -> exiting';
        exit 1;
    fi
}

function error_exit {

set +o nounset
    local exit_code=$?
local msg="$1"    
local file="$2"
local line="$3"

echo -n "[ Exit_code: $exit_code ]"
local cmd="print_color 31  \"$msg\""
eval "$cmd"

case $msg in
    SIGHUP)
        ;;
    SIGTERM)
        ;;
    SIGERR)


        print_status
    


print_color 31 "$file $line"
        echo 
        local file="${BASH_SOURCE[1]}"
        echo 
        local line="${BASH_LINENO[0]}"
        local cmd="vi $file +$line"
        #update_clipboard "$cmd"
       # echo "$0"
#        echo "$LINENO"
       # echo "$BASH_LINENO"

print_file /tmp/proxy 5
        go_home
        #cat   /tmp/proxy | tail -2
        ;;
    SIGINT)
print_file /tmp/proxy 5
        #cat /tmp/proxy | tail -2
        go_home

        #breaking
        ;;
esac
#trace exit 1
#eval    go_home
}
#Trap the killer signals so that we can exit with a good message.
#trap "error_exit 'SIGHUP'" SIGHUP
#trap "error_exit 'SIGINT'" SIGINT
#trap "error_exit 'SIGTERM'" SIGTERM
if [ "$TRAP_ERROR" = true ];then
    trap "error_exit SIGERR $LINENO $BASH_SOURCE" ERR
else
    proxy "print_color 31 'skipp trapping errors'"
fi

broadcast(){
    proxy 'echo BROADCASTING'
local str="$@"
xcowsay "$str" &
notify-send "$str" &
flite -t "$str" &
}
trace(){
    local verbose="${VERBOSE:-true}"
    if [ "$verbose" =  true ];then
       print_color 33 "[TRACE] $@" 
            fi
    }
    print_status(){
print_color 32        echo '[PRINT STATUS]'
    set -o | grep pipe
    set -o | grep nounset
    set -o | grep trace
    set -o | grep exit
    echo "sh_wrapper: $sh_wrapper"
   echo "TRAP_ERROR:  $TRAP_ERROR" 
    
    }
export -f proxy
export -f breaking
export -f error_exit 
export -f go_home
export -f random
export -f every
export -f broadcast
export -f trace
export -f print_status

export -f print_file
#set +o nounset
