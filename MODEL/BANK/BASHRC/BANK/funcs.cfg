shopt -s expand_aliases
trap_sigterm(){
    proxy print_color 34 SIGTERM
present pv 'only if frustrated...'
present pv 'random teacher in 5 seconds'
proxy sleep 4
present toilet 'love wisdom'
( xdg-open http://wiki.bash-hackers.org/ &)

}
#echo trap trap_sigterm SIGTERM
quick_follow(){ local dir=$1;pushd "$( readlink -m $dir )"; }
export -f quick_follow
print_func(){
echo "${FUNCNAME[0]}"
}
confirm(){
    local  args=( $@ )
    local cmd="${args[@]}"

    echo "[CONFIRM] $cmd"
    echo 'y/n ?'
    read answer
    if [ "$answer" = y ];then
        echo running
        proxy sleep 2

        proxy "$cmd"
    else
        proxy echo skipping
        proxy sleep 2
        proxy go_home
    fi
}
random_line(){
    local file=$1
    if [ -f $file ];then
        local num=$(       cat $file | wc -l ) 
        local str=$(cat $file | tail -${num} | head -1)
        echo "$str"
    else
        echo 'file not found: ' "$file"

    fi
}
#translate(){

#       http://www.commandlinefu.com/commands/matching/translate/dHJhbnNsYXRl/sort-by-votes
#    wget -qO- "http://ajax.googleapis.com/ajax/services/language/translate?v=1.0&q=$1&langpair=$2|${3:-en}" | sed 's/.*"translatedText":"\([^"]*\)".*}/\1\n/'; } 
go_home(){
    #    cat -n /tmp/proxy | tail -2
    every 5 "echo 'type: logs for watching last proxied commands'"
    local cmd_to_source_exit='return 0'
    local cmd_to_script_exit='exit 1'
    print_color_n 32 '[GO_HOME]'
    local file="$BASH_SOURCE"
    if [ "$file" = bash ];then
        eval "$cmd_to_source_exit"
    else
        eval "$cmd_to_script_exit"
    fi
}


print_color () 
{ 
    echo -e "\x1B[01;$1m[*]\x1B[0m $2 "
}
print_color_n () 
{ 
    echo -en "\x1B[01;$1m[*]\x1B[0m $2 "
}





print_shlvl(){
    echo "SHLVL: $SHLVL"
    proxy sleep 2
}
update_clipboard(){
    #print_shlvl
    local args=( $@ )
    local cmd="${args[@]}"
    print_color 33 "[CLIPBOARD] $cmd"
    #     local str_caller=`    caller`
    #     local cmd="echo $str;vi +${str_caller}"

    #proxy "notify-send 'update clipboard'"
    present notify-send update clipboard
    #'$cmd' "
    echo "$cmd" | xsel --clipboard
}



#info:   first list
#pending
who_am_i(){
    local filename=`basename $BASH_SOURCE`
    local dir=$( where_am_i )
    echo "$dir/$filename"
}
where_am_i(){
    ########### method1
    #use: /bin/readline
    #echo caller `    caller`
    #echo
    #    sleep 2
    local file=${1:-"${BASH_SOURCE[1]}"}
    local  rpath=$(readlink -m $file)
    local   rcommand=${rpath##*/}
    local  str_res=${rpath%/*}
    ########### method2
    #use:bash builtin: caller
    #local rpath=$( caller | cut -d' ' -f2 | xargs dirname )

    local  dir_self="$( cd $str_res  && pwd )"
    #local cmd="present notify-send 'where_am_i' '$dir_selfr'"
    #proxy "$cmd"
    echo "$dir_self"
}
just(){
    print_color 33 "[JUST] " 
    echo "$@"
    echo   "$cmd_to_exit"
    proxy "sleep 2"
    eval "$cmd_to_exit"
}

random() 
{ 
    #    print_func;

    local num=$1
    let "r = $RANDOM % $num";
    return $r
}

every () 
{ 
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};
    if [ -z "$cmd_else" ];then
        cmd_else="trace $cmd_do"
    fi
    local res=0;
    if [ $num -eq 0 ]; then
        res=0;
    else
        random $num;
    fi;
    res=$?;
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "boom/$num";
        eval "$cmd_do";
    else
        eval "$cmd_else";
    fi
}
assert () 
{ 
    #delegate: returnin, exiting 
    register 
    local args=("$@");

    #add_test "${args[@]}";
    proxy sleep 1
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            dir_exist)
                [ -d "$item" ] && res=0
                ;;
            file_exist)
                [ -f "$item" ] && res=0
                ;;
            file_has_content)
                [ -s "$item" ] && res=0
                ;;
            string_has_content)
                [ -n "$item" ] && res=0
                ;;
            func_exist)
                type $item 1>/dev/null && { res=0; }
                ;;

            *)
                present echo "assertion not defined yet: $action"
                go_home
                ;;
        esac;
    else
        present echo "supply 2 args: $@";
        go_home
    fi;


    if [ $res -eq 1 ];then
        
    echo "ASSERT: error"
        go_home
    else
#trace "ASSERT: ok"
echo -n '...'
    fi
}
register(){
    local str_caller="vi +$(caller)"
    update_clipboard "$str_caller"
    echo "$str_caller" >> /tmp/callers
}

pending(){
    echo "[PENDING]" "$@"
}
present() 
{ 
    #dont call present() through proxy - it use the proxy itself
    local type=$1;
    shift
    local args=( $@ )
    local cmd="${args[@]}"
    proxy "$type $cmd"
}
pv(){
    echo "$@" |  /usr/bin/pv -qL 10 
}
trace(){
    echo "$@" >> /tmp/proxy
}
toilet(){
    local args="$@"
local util=`which toilet`
local cmd="$util --gay"
eval "$cmd $args"

}
export -f toilet
#export -f assert
export -f register
export -f every
export -f random
export -f assert

#export -f proxy
export -f go_home
export -f print_color

export -f print_color_n
export -f where_am_i
#export -f run_dir
export -f update_clipboard
#export -f util

#export -f callers
export -f pv
#export -f translate
export -f pending
export -f who_am_i
export -f register
export -f trace
export -f present
#export present="proxy"
alias funcsE="vim $(  who_am_i )"
alias toilet="/usr/bin/toilet --gay"
export -f random_line
export -f confirm
export -f print_func
export -f print_shlvl

#export -f trap_sigterm
