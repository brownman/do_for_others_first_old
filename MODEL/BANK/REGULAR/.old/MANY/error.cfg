#set -o nounset
alias proxyE="vi $BASH_SOURCE"
print_file(){
local limit=5
    local file=$1
local max=$( cat $file | wc -l )
if [ $max -gt $limit ];then
    max=$limit
    fi
#    local max=$2
    echo


    print_color_n 31 "[FILE]"

    echo " $file [ $max ] "
    echo "----"
    echo
    cat $file | tail -${max}
    echo
    echo '---'
    }
random () 
{ 
    local num=$1;
    let "r = $RANDOM % $num";
    return $r
}

every () 
{ 
    local num=${1:-5};
    local cmd_do="$2";
    local cmd_else=${3:-''};
    local res=0
    if [ $num -eq 0 ];then
        res=0
    else
        random $num;
    fi
    res=$?;
    if [ $res -eq 0 ]; then
        notify-send "life is random! :)" "boom/$num";
        eval "$cmd_do";
    else
        eval "$cmd_else";
    fi
}
sleep(){
    local num=$1
#    if [ "$DEBUG" = true ];then
        proxy "print_color_n 31 '[Zzzz] '"
        echo "$num"
        /bin/sleep $num
 #   else
  #      proxy "debug false -> skip sleeping"
  #  fi

}


breaking(){
    echo ' [ breaking ]'
    break
}

present_tmp_files(){
    
print_file /tmp/clip
print_file /tmp/proxy 
print_file /tmp/err
    }
catch_error_line(){
    print_color 31 "$file $line"
        echo 
        local file="${BASH_SOURCE[1]}"
        echo 
        local line="${BASH_LINENO[0]}"
        local cmd="vi $file +$line"
        echo "$cmd" >> /tmp/clip
proxy         sleep  2

    }
function error_exit {

set +o nounset
    local exit_code=$?
local msg="$1"    
local file="$2"
local line="$3"

proxy "print_color 31  '[ERROR]'"
echo -n "[ Exit_code: $exit_code ] $msg $file $line"
proxy sleep 2

        print_status
case $msg in
    SIGHUP)
    
        ;;
    SIGTERM)
        ;;
    SIGERR)
    catch_error_line
    present_tmp_files
        go_home
        ;;
    SIGINT)
        ;;
esac
#trace exit 1
#eval    go_home
}
#Trap the killer signals so that we can exit with a good message.
#trap "error_exit 'SIGHUP'" SIGHUP
#trap "error_exit 'SIGINT'" SIGINT
#trap "error_exit 'SIGTERM'" SIGTERM
set_error_handler(){
   echo '[ERROR HANDLER] is being set..' 

if [ "$TRAP_ERROR" = true ];then
    trap "error_exit SIGERR $LINENO $BASH_SOURCE" ERR
else
    proxy "print_color 31 'skipp trapping errors'"
fi

    }

broadcast(){
    proxy 'echo BROADCASTING'
local str="$@"
xcowsay "$str" &
notify-send "$str" &
flite -t "$str" &
}
trace(){
    local verbose="${VERBOSE:-true}"
    if [ "$verbose" =  true ];then
       print_color 33 "[TRACE] $@" 
            fi
    }
    print_status(){
    echo '[PRINT STATUS]'
    set -o | grep pipe
    set -o | grep nounset
    set -o | grep trace
    set -o | grep exit
    echo "sh_wrapper: $sh_wrapper"
   echo "TRAP_ERROR:  $TRAP_ERROR" 
    
   sleep 2
    }
#    set_error_handler
#export -f proxy
#export -f breaking
#export -f error_exit 
#export -f go_home
#export -f random
#export -f every
#export -f broadcast
#export -f trace
#export -f print_status
#export -f set_error_handler
#export -f print_file
#set +o nounset
