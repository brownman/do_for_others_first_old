#alias proxy 1>/dev/null  2>/dev/null && { unalias proxy; }
alias proxyE="vi $BASH_SOURCE"
install_trap(){
exec 2>/tmp/err
trap trap_err ERR
export -f trap_err_0
}
ensure_escaped(){
    local str="$cmd"
    echo "str: $str"
local str1=$( echo "$str" | sed 's/"/\\"/g' ) 
echo "str1: $str1"
    local str2=$(  echo 1>/dev/null "$str1" | grep '\\\\' )  && { echo "$str1"; } || { echo "$str"; }
# echo "$str1" | grep '\\\\'  && { echo "$str1"; } || { echo "$str"; } 
    echo "str2: $str2"
#    echo "$str2"
}
proxy () 
{ 
#pending   assert string_is_escaped "$cmd" 
#attention: proxy must not contain calls to itself !!!
    local str_caller=`caller`;

    local args=($@);
    local cmd="${args[@]}";

#    cmd=$( ensure_escaped "$cmd" )

    local msg="gvim +$str_caller"
    local max="${#args[@]}";

    
    
    local runner="${args[0]}";
    local verbose=${VERBOSE:-false};
    type "$runner" > /dev/null 2> /dev/null || { 
        echo "[ERROR] command not found: $runner";
        go_home
    };
    if [ "$verbose" = true ]; then
        echo "PROXY ($max): $cmd";
    fi;
    echo "$msg: $cmd" >> /tmp/proxy;
 #   echo $msg
 eval "$cmd" 2>/tmp/err || { gxmessage  -timeout 10 -file /tmp/err -entrytext "$msg"; go_home; }
 
}
export -f proxy
export -f ensure_escaped
