#info
alias ensureE="vi  $BASH_SOURCE"
compare_2(){
    case "$action" in 
        more)
            [ "$item" -gt "$item2" ] && res=0
            ;;
        *)
            echo "assertion not defined yet: $action"
            go_home
            ;;
    esac;

}

compare_1(){
    case "$action" in 
        num_not_zero)
            [ "$item" -ne 0 ] && res=0
            ;;

        dir_exist)
            [ -d "$item" ] && res=0
            ;;
        string_is_escaped)
            ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
            ;;

        file_exist)
            [ -f "$item" ] && res=0
            ;;
        caller_is)
            if [ "${#BASH_SOURCE[@]}" -gt 0 ];then
                if [ "${#FUNCNAME[@]}" -gt 0 ];then
                    local funcname2="${FUNCNAME[2]}"
                    local funcname1="${FUNCNAME[1]}"
                    if [ $funcname2 = "$item"  ] || [ $funcname2 = "${item}1" ];then
                        res=0
                    else
                        echo "[ ERROR ]"

                        echo "only ${item} should call $funcname1"

                        echo "[BUT] ${funcname2} calls ${funcname1} "
                        local msg="gvim ${BASH_SOURCE[2]}"
                        echo                proxy update_clipboard "$msg"
                    fi
                fi
            fi
            ;;

        file_has_content)
            [ -s "$item" ] && res=0
            ;;
        string_has_content)
            [ -n "$item" ] && res=0
            ;;
        func_exist)
            type $item 1>/dev/null && { res=0; }
            ;;
        *)
            echo "assertion not defined yet: $action"
            go_home
            ;;
    esac;
}
assert () 
{ 


    #set -e
    #set -u
    #delegate: returnin, exiting 
    local args=($@);

local str_caller=`caller`
    #    local cmd="${args[@]}"
    action="${args[0]}";
    item="${args[1]}";

    #who_is_asking `caller` 
    #add_test "${args[@]}";
    let 'res=1';
    local max="${#args[@]}"
    if [ "$max" -eq 2 ]; then
        compare_1
    elif [ "$max" -eq 3 ]; then
        item2="${args[2]}";
        compare_2
    else
        echo        reason_of_death "supply: 1.assertioin 2.arg to compare" "$@"
        go_home
    fi;


    if [ $res -eq 1 ];then
echo
        echo -n "[ASSERT] " 
        echo  Error
        echo [caller] "$str_caller"
        echo [args] "${args[@]}"
        echo
        #register  
        #proxy present print_color 31 "ASSERT: error action:$action item:$item"
        go_home
        #   else
        #trace "ASSERT: ok"
        #        echo -n '...'
    #else
    #    echo [assert] [$@] ok
    fi
    #    set +e
    #    set +u
}

ensure(){
    #info: create/do + no outpu
    #delegate: returnin, exiting 
    #who_is_asking `caller` 
    local args=($@);
    local cmd="${args[@]}"
    #add_test "${args[@]}";
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            string_is_escaped)
                ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
                ;;
            file_exist)
                touch $item 
                ;;
            *)
                register 
                echo "type of ensure - has not defined yet: $action "
                ;;
        esac;
    else
        echo echo "supply 2 args: $@";
    fi;

}



export -f compare_1
export -f compare_2
export -f assert
export -f ensure
