#info
alias ensureE="vi  $BASH_SOURCE"
assert () 
{ 
    #delegate: returnin, exiting 
    set -e
    local args=($@);
    local cmd="${args[@]}"
    #add_test "${args[@]}";
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            num_not_zero)
                [ "$item" -ne 0 ] && res=0
                ;;

            dir_exist)
                [ -d "$item" ] && res=0
                ;;
            string_is_escaped)
                ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
                ;;

            file_exist)
                [ -f "$item" ] && res=0
                ;;
            caller_is)
                if [ "${#BASH_SOURCE[@]}" -gt 0 ];then
                    if [ "${#FUNCNAME[@]}" -gt 0 ];then
                        local funcname2="${FUNCNAME[2]}"
                        local funcname1="${FUNCNAME[1]}"
                        if [ $funcname2 = "$item"  ] || [ $funcname2 = "${item}1" ];then
                            res=0
                        else
                            proxy present print_color 31 "[ ERROR ] [ func:${funcname2} ] is calling [ func:${funcname1} ] but should be called through [func: ${item} ]"
                            local msg="gvim +${BASH_SOURCE[2]}"
                            proxy update_clipboard "$msg"
                        fi
                    fi
                fi
                ;;

            file_has_content)
                [ -s "$item" ] && res=0
                ;;
            string_has_content)
                [ -n "$item" ] && res=0
                ;;
            func_exist)
                type $item 1>/dev/null && { res=0; }
                ;;

            *)

                echo "assertion not defined yet: $action"

                go_home
                ;;
        esac;
    else
echo        reason_of_death "supply 2 args:" "$@"
    fi;


    if [ $res -eq 1 ];then
        register  
        proxy present print_color 31 "ASSERT: error action:$action item:$item"
        go_home
        #   else
        #trace "ASSERT: ok"
        #        echo -n '...'
    fi
    set +e
}

ensure(){
    #info: create/do + no outpu
    #delegate: returnin, exiting 
    who_is_asking `caller` 
    local args=($@);
    local cmd="${args[@]}"
    #add_test "${args[@]}";
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            string_is_escaped)
                ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
                ;;
            file_exist)
                touch $item 
                ;;


            *)

                register 
                echo "type of ensure - has not defined yet: $action "
                ;;
        esac;
    else
        echo echo "supply 2 args: $@";
    fi;

}


export -f assert
export -f ensure
