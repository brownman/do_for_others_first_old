#info
assert () 
{ 
    #delegate: returnin, exiting 

    local args=($@);
    local cmd="${args[@]}"
    #add_test "${args[@]}";
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            dir_exist)
                [ -d "$item" ] && res=0
                ;;
            string_is_escaped)
                ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
                ;;

            file_exist)
                [ -f "$item" ] && res=0
                ;;
#            caller_is)
                #    proxy gxmessage "$( caller )" -title 'caller_is'
                #notify-send 'call sleep' "$(caller)"
 #               [ "${FoUNCNAME[2]}" = "$item" ] && { res=0; } || { echo error - caller is not $item ;} 
  #              ;;
            file_has_content)
                [ -s "$item" ] && res=0
                ;;
            string_has_content)
                [ -n "$item" ] && res=0
                ;;
            func_exist)
                type $item 1>/dev/null && { res=0; }
                ;;

            *)

                present echo "assertion not defined yet: $action"

                echo "[ AVAILABLE: cases]"
                `cat $BASH_SOURCE | grep ')'`
                go_home
                ;;
        esac;
    else
        present echo "supply 2 args: $@";
        go_home
    fi;


    if [ $res -eq 1 ];then


        register 
        echo "ASSERT: error"
        go_home
    else
        #trace "ASSERT: ok"
        echo -n '...'
    fi
}

ensure(){
    #delegate: returnin, exiting 

    local args=($@);
    local cmd="${args[@]}"
    #add_test "${args[@]}";
    let 'res=1';
    if [ "${#args[@]}" -eq 2 ]; then
        local action="${args[0]}";
        local item="${args[1]}";
        case "$action" in 
            dir_exist)
                [ -d "$item" ] && res=0
                ;;
            string_is_escaped)
                ( 1>/dev/null; echo "$cmd" | sed 's/"/\"/g' | grep '\\' ) && { res=0; }
                ;;

            file_exist)
                [ -f "$item" ] && res=0
                ;;
            caller_is)

                #    proxy gxmessage "$( caller )" -title 'caller_is'
                #notify-send 'call sleep' "$(caller)"
local funcname="${FUNCNAME[2]}"
#        regex='^([a-z]{1,}) ([0-9]{1,})$'

#local        regex="^proxy\$"
#([0-9])\$"
#  regex="^${error_file}\$|^${error_file}\s+|\s+${error_file}\s+|\s+   ${error_file}\$"
#              if [[ "$_backtrace" =~ $regex ]]

        
            #if [[ $error_lineno =~ $regex ]]

            #xcowsay "funcname: $funcname"

                if [ "$item" = "${funcname}" ] || [ "${item}1" = "$funcname" ];then

#                 { echo "OK caller is proxy" ;res=0; }
echo -n ''

                    else

                 { echo "ERROR - caller is not $item" ;} 
                        fi


                ;;
            file_has_content)
                [ -s "$item" ] && res=0
                ;;
            string_has_content)
                [ -n "$item" ] && res=0
                ;;
            func_exist)
                type $item 1>/dev/null && { res=0; }
                ;;

            *)
                present echo "assertion not defined yet: $action"
                ;;
        esac;
    else
        present echo "supply 2 args: $@";
    fi;

}


export -f assert
export -f ensure
