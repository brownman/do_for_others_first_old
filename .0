#!/bin/bash 
source $dir_root/.WORKSPACE/BANK/CFG/1_struct.cfg
source $dir_production/PROJECT/PENDING/0_SOURCE/STEP1/breath.cfg 
source $dir_production/PROJECT/PENDING/0_SOURCE/STEP2/breath.cfg 
bash -c $dir_root/IMAGINE/breath.cfg
source $dir_root/.CODE/PRESENT/sos_cfg_for_presentation.cfg
echo


bash -c     $dir_workspace/BANK/LISTS/SETUP/breath.cfg 
set -o nounset

exec 2>/tmp/err

sleep  2
    export file_runner=$0
dir_self=$( dirname $file_runner )

    cat  $dir_self/env.cfg
    source $dir_self/env.cfg
    source $dir_self/traps.cfg

    alias firstE="gvim $file_runner"

#set -x
#source $dir_root/.3
    quick(){
        echo presentation remind of  the big stones
            alias robot="robot_steps"

    }
i_have_my(){
    local tag=$1
        local funcname=${FUNCNAME[1]}
    cmd="cat $file_runner | grep $funcname -A 2 | grep $tag"
        eval "$cmd"
}
step_tty_clear(){
#url: http://unix.stackexchange.com/questions/3981/how-to-clear-terminal-after-logging-out

#    [ $MODE_TTY = true ] &&  clear>$file_output
    echo
}

breaking(){
    local str_caller=`caller`
        echo "-- [ $FUNCNAME ] --"
        print_color 32 "[^B]"
        local cmd="gvim +${str_caller}" 
        echo  "$cmd"
#proxy    update_clipboard "$cmd"
        break
}
step_struct(){

}

step_source1(){
#check: type proxyi1 1>/dev/null
#source $dir_root/bashrc_additions.cfg
    echo silent sourcing 

}
step_source2(){
#check: type proxy 1>/dev/null
}
step_imagine(){

}
step_export_funcs(){

}

stepper(){
#clear
#    local  str="$@"
#    set -u
#    echo $@

    local args=( $@ )
        local cmd="${args[@]}"

        echo -n "[ $FUNCNAME ]"
############################ intro
        local str_min=$( echo "${args[1]}" | sed 's/step_//g' | sed 's/_/ /g' )
        local str_type=$( echo "${args[0]}" | cut -d'_' -f1 )
#    local str_show=${MODE_DEBUG:-true}

        echo -ne "[$str_type] $str_min \t\t"
#####################################################
#        proxy sleep 2
#echo       "  eval \"$str\" >>$file_output"
        echo "[cmd] $cmd"
#    if [ "$MODE_TTY" =  true ];then
#        eval "$cmd" >"$file_output"
#    else
        eval "$cmd"  
#    fi

        res=$?
        if [ $res -ne 0 ];then
            print_color 31 "\t "
#    breaking
        else

            print_color 32 "\t "
#step_inline_test
                fi
}




step_explain_self(){
    echo think neat 
        echo
        type steps
        proxy sleep 2
}
source_it(){
    echo -n "$FUNCNAME "
        echo "$@"
        eval "$@" 
}
run_it(){
    echo -n "$FUNCNAME "
        echo "$@"

        (   eval "$@"  )
}
step_setup(){

#1>/tmp/out
}



loop(){
#info: loop over a list of commands: 2 options: source_it/run_it
#reason: list is wonderful but tearsome if not sourcing the library first
#    print_color 35 OK
    set -x
        set -u
        echo "$FUNCNAME"


        echo $dir_self
        local file_list=$dir_self/list.txt
        ls $file_list
        local counter=1

        while read line;do
            breaking
                if [ -n  "$line" ];then
                    echo -n  "${counter} "
#                    echo $line
                        eval "$line"
                else
#breaking
#   proxy go_home
#        echo "[]"
                    echo -n "."
                        fi
                        let 'counter += 1'
                        done < $file_list
}
step_cheat(){
#info: source the library first
#reason: encourage updating saperate  files and group them under folders instead of increasing dis-order by updating some: helper.cfg
    echo $FUNCNAME
        stepper source_it       step_struct
        stepper source_it       step_source1 
        echo         i_have_my reason
}
step_sos(){
    (    [ "$MODE_SOS"  =  true ] && { head -2 $dir_root/plan.txt ;sleep 4 ; } )
}
sos_file_present () 
{ 
    local file=$1;
    local util=`which pv`;
    local cmd="cat $file | xargs -0 echo | $util -qL 10";
    eval "$cmd"
}

#step_show_motivation(){
#    [ $file_runner != bash ]  &&  { every 3    step_sos ;    }
#}
steps (){
    echo $FUNCNAME
        [ "$MODE_TRAP_ERR" = true ] && step_set_trap
        [ "$MODE_TTY" = true ] &&    step_tty_clear
#every 4    step_show_motivation
#        type cheat
#       cheat
#       print_color 36 done

#step_cheat
        loop


}
steps
